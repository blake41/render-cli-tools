#!/usr/bin/env node
/**
 * browser-logs - Stream browser console logs via Chrome DevTools Protocol
 * 
 * Connects to a Chrome instance with remote debugging enabled and streams
 * all console output, errors, exceptions, and network errors to the terminal.
 * 
 * Usage:
 *   browser-logs                     # Connect to localhost:9222
 *   browser-logs --port 9223         # Custom port
 *   browser-logs --level error       # Filter by level
 *   browser-logs --clear             # Clear console on connect
 *   browser-logs --json              # Output as JSON
 * 
 * Launch Chrome with debugging:
 *   open -na "Google Chrome" --args --remote-debugging-port=9222 \
 *     --user-data-dir="/Users/blake/.cursor-chrome-profile" "http://localhost:5173"
 */

const CDP = require('chrome-remote-interface');

// ANSI colors
const colors = {
  reset: '\x1b[0m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
  bgRed: '\x1b[41m',
  white: '\x1b[37m',
};

// Parse arguments
const args = process.argv.slice(2);
const config = {
  port: 9222,
  host: 'localhost',
  level: null,  // null = all levels
  clear: false,
  json: false,
  network: true,
  help: false,
};

for (let i = 0; i < args.length; i++) {
  switch (args[i]) {
    case '--port':
    case '-p':
      config.port = parseInt(args[++i], 10);
      break;
    case '--host':
      config.host = args[++i];
      break;
    case '--level':
    case '-l':
      config.level = args[++i];
      break;
    case '--clear':
    case '-c':
      config.clear = true;
      break;
    case '--json':
    case '-j':
      config.json = true;
      break;
    case '--no-network':
      config.network = false;
      break;
    case '--help':
    case '-h':
      config.help = true;
      break;
  }
}

if (config.help) {
  console.log(`
browser-logs - Stream browser console logs via Chrome DevTools Protocol

USAGE
  browser-logs [options]

OPTIONS
  --port, -p N       CDP port (default: 9222)
  --host HOST        CDP host (default: localhost)
  --level, -l LEVEL  Filter: log, info, warn, error, debug
  --clear, -c        Clear browser console on connect
  --json, -j         Output as JSON lines
  --no-network       Don't show network errors
  --help, -h         Show this help

EXAMPLES
  # Start Chrome with debugging enabled
  open -na "Google Chrome" --args \\
    --remote-debugging-port=9222 \\
    --user-data-dir="/Users/blake/.cursor-chrome-profile" \\
    "http://localhost:5173"

  # Stream all logs
  browser-logs

  # Only errors
  browser-logs --level error

  # JSON output for parsing
  browser-logs --json

LOG LEVELS
  log     - console.log()
  info    - console.info()
  warn    - console.warn() 
  error   - console.error(), exceptions, network errors
  debug   - console.debug()

NOTES
  - Captures: console.*, exceptions, promise rejections, network failures
  - Multiple tabs: logs from ALL open tabs are captured
  - Chrome must be launched with --remote-debugging-port=9222
`);
  process.exit(0);
}

// Map CDP log types to our levels
function normalizeLevel(type) {
  const map = {
    'log': 'log',
    'info': 'info', 
    'warning': 'warn',
    'warn': 'warn',
    'error': 'error',
    'debug': 'debug',
    'trace': 'debug',
    'dir': 'log',
    'dirxml': 'log',
    'table': 'log',
    'count': 'log',
    'assert': 'error',
    'timeEnd': 'log',
    'exception': 'error',
  };
  return map[type] || 'log';
}

// Check if we should show this level
function shouldShow(level) {
  if (!config.level) return true;
  const levels = ['debug', 'log', 'info', 'warn', 'error'];
  const configIdx = levels.indexOf(config.level);
  const msgIdx = levels.indexOf(level);
  return msgIdx >= configIdx;
}

// Format timestamp
function timestamp() {
  return new Date().toISOString().split('T')[1].slice(0, 12);
}

// Get color for level
function levelColor(level) {
  switch (level) {
    case 'error': return colors.red;
    case 'warn': return colors.yellow;
    case 'info': return colors.blue;
    case 'debug': return colors.gray;
    default: return colors.reset;
  }
}

// Format a log entry
function formatLog(entry) {
  if (config.json) {
    console.log(JSON.stringify(entry));
    return;
  }
  
  const { level, message, source, url, line } = entry;
  const color = levelColor(level);
  const ts = colors.dim + timestamp() + colors.reset;
  const lvl = color + level.toUpperCase().padEnd(5) + colors.reset;
  
  let location = '';
  if (url && !url.startsWith('chrome://')) {
    const shortUrl = url.replace(/.*\//, '').split('?')[0];
    location = colors.dim + ` (${shortUrl}${line ? ':' + line : ''})` + colors.reset;
  }
  
  console.log(`${ts} ${lvl} ${message}${location}`);
}

// Extract message from CDP args
function extractMessage(args) {
  if (!args || args.length === 0) return '';
  
  return args.map(arg => {
    if (arg.type === 'string') return arg.value;
    if (arg.type === 'number') return String(arg.value);
    if (arg.type === 'boolean') return String(arg.value);
    if (arg.type === 'undefined') return 'undefined';
    if (arg.type === 'object') {
      if (arg.subtype === 'null') return 'null';
      if (arg.preview) {
        // Format object preview
        if (arg.preview.type === 'array') {
          const items = arg.preview.properties.map(p => p.value).join(', ');
          return `[${items}${arg.preview.overflow ? ', ...' : ''}]`;
        }
        const props = arg.preview.properties.map(p => `${p.name}: ${p.value}`).join(', ');
        return `{${props}${arg.preview.overflow ? ', ...' : ''}}`;
      }
      return arg.description || '[object]';
    }
    if (arg.type === 'function') return arg.description || '[function]';
    return arg.description || arg.value || String(arg.type);
  }).join(' ');
}

async function main() {
  let client;
  
  try {
    // List available targets
    const targets = await CDP.List({ port: config.port, host: config.host });
    const pages = targets.filter(t => t.type === 'page');
    
    if (pages.length === 0) {
      console.error(`${colors.red}No browser pages found on ${config.host}:${config.port}${colors.reset}`);
      console.error(`\nMake sure Chrome is running with remote debugging:`);
      console.error(`  open -na "Google Chrome" --args --remote-debugging-port=${config.port} \\`);
      console.error(`    --user-data-dir="/Users/blake/.cursor-chrome-profile" "http://localhost:5173"`);
      process.exit(1);
    }

    if (!config.json) {
      console.log(`${colors.cyan}● Connected to Chrome${colors.reset} (${pages.length} page${pages.length > 1 ? 's' : ''})`);
      console.log(`${colors.dim}  Press Ctrl+C to stop${colors.reset}\n`);
    }

    // Connect to all pages
    const clients = [];
    for (const target of pages) {
      try {
        const c = await CDP({ target, port: config.port, host: config.host });
        clients.push(c);
        await setupListeners(c, target.title || target.url);
      } catch (e) {
        // Some targets may not be connectable
      }
    }

    if (clients.length === 0) {
      console.error(`${colors.red}Could not connect to any pages${colors.reset}`);
      process.exit(1);
    }

    // Handle new targets (new tabs)
    const cdp = await CDP({ port: config.port, host: config.host });
    const { Target } = cdp;
    await Target.setDiscoverTargets({ discover: true });
    
    Target.targetCreated(async ({ targetInfo }) => {
      if (targetInfo.type === 'page') {
        try {
          const c = await CDP({ target: targetInfo.targetId, port: config.port, host: config.host });
          clients.push(c);
          await setupListeners(c, targetInfo.title || targetInfo.url);
          if (!config.json) {
            console.log(`${colors.cyan}● New tab connected${colors.reset}`);
          }
        } catch (e) {
          // Ignore connection errors for new targets
        }
      }
    });

    // Keep alive
    process.on('SIGINT', async () => {
      if (!config.json) {
        console.log(`\n${colors.dim}Disconnecting...${colors.reset}`);
      }
      for (const c of clients) {
        try { await c.close(); } catch (e) {}
      }
      process.exit(0);
    });

  } catch (err) {
    if (err.code === 'ECONNREFUSED') {
      console.error(`${colors.red}Cannot connect to Chrome on ${config.host}:${config.port}${colors.reset}`);
      console.error(`\nStart Chrome with remote debugging enabled:`);
      console.error(`  open -na "Google Chrome" --args --remote-debugging-port=${config.port} \\`);
      console.error(`    --user-data-dir="/Users/blake/.cursor-chrome-profile" "http://localhost:5173"`);
    } else {
      console.error(`${colors.red}Error: ${err.message}${colors.reset}`);
    }
    process.exit(1);
  }
}

async function setupListeners(client, tabName) {
  const { Runtime, Log, Network, Console } = client;

  // Enable domains
  await Promise.all([
    Runtime.enable(),
    Log.enable(),
    config.network ? Network.enable() : Promise.resolve(),
  ]);

  // Clear console if requested
  if (config.clear) {
    try {
      await Runtime.discardConsoleEntries();
    } catch (e) {}
  }

  // Console API calls (console.log, etc.)
  Runtime.consoleAPICalled(({ type, args, stackTrace }) => {
    const level = normalizeLevel(type);
    if (!shouldShow(level)) return;

    const message = extractMessage(args);
    const location = stackTrace?.callFrames?.[0];
    
    formatLog({
      level,
      message,
      source: 'console',
      url: location?.url,
      line: location?.lineNumber,
      timestamp: new Date().toISOString(),
    });
  });

  // Exceptions
  Runtime.exceptionThrown(({ exceptionDetails }) => {
    if (!shouldShow('error')) return;

    const { text, exception, url, lineNumber, stackTrace } = exceptionDetails;
    let message = text;
    
    if (exception) {
      message = exception.description || exception.value || text;
    }

    formatLog({
      level: 'error',
      message: `${colors.bgRed}${colors.white} EXCEPTION ${colors.reset} ${message}`,
      source: 'exception',
      url,
      line: lineNumber,
      timestamp: new Date().toISOString(),
    });
  });

  // Browser console entries (Log domain)
  Log.entryAdded(({ entry }) => {
    const level = normalizeLevel(entry.level);
    if (!shouldShow(level)) return;

    formatLog({
      level,
      message: entry.text,
      source: entry.source,
      url: entry.url,
      line: entry.lineNumber,
      timestamp: entry.timestamp,
    });
  });

  // Network failures
  if (config.network) {
    Network.loadingFailed(({ requestId, errorText, type }) => {
      if (!shouldShow('error')) return;
      if (errorText === 'net::ERR_ABORTED') return; // Ignore cancelled requests

      formatLog({
        level: 'error',
        message: `${colors.bgRed}${colors.white} NETWORK ${colors.reset} ${errorText} (${type})`,
        source: 'network',
        timestamp: new Date().toISOString(),
      });
    });

    // HTTP errors (4xx, 5xx)
    Network.responseReceived(({ response }) => {
      if (!shouldShow('error')) return;
      if (response.status >= 400) {
        formatLog({
          level: 'error', 
          message: `${colors.bgRed}${colors.white} HTTP ${response.status} ${colors.reset} ${response.url.split('?')[0]}`,
          source: 'network',
          timestamp: new Date().toISOString(),
        });
      }
    });
  }
}

main();
