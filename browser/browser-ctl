#!/usr/bin/env node
/**
 * browser-ctl - Control browser via Playwright + CDP
 * 
 * Connects to Chrome with remote debugging and provides full control:
 * - Screenshots
 * - Console logs
 * - Click, type, navigate
 * - JavaScript evaluation
 * - Accessibility snapshots
 * 
 * Usage:
 *   browser-ctl screenshot                    # Screenshot current page
 *   browser-ctl logs                          # Stream console logs
 *   browser-ctl click "button.submit"         # Click element
 *   browser-ctl goto "/accounts"              # Navigate
 *   browser-ctl eval "document.title"         # Run JS
 */

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');

// Config
const CDP_PORT = process.env.CDP_PORT || 9222;
const CDP_HOST = process.env.CDP_HOST || 'localhost';
const SCREENSHOT_DIR = process.env.SCREENSHOT_DIR || '/tmp/browser-ctl';

// ANSI colors
const c = {
  reset: '\x1b[0m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
};

// Ensure screenshot directory exists
if (!fs.existsSync(SCREENSHOT_DIR)) {
  fs.mkdirSync(SCREENSHOT_DIR, { recursive: true });
}

async function connect() {
  try {
    const browser = await chromium.connectOverCDP(`http://${CDP_HOST}:${CDP_PORT}`);
    const contexts = browser.contexts();
    if (contexts.length === 0) {
      console.error(`${c.red}No browser contexts found${c.reset}`);
      process.exit(1);
    }
    const pages = contexts[0].pages();
    if (pages.length === 0) {
      console.error(`${c.red}No pages found${c.reset}`);
      process.exit(1);
    }
    return { browser, page: pages[0], contexts };
  } catch (err) {
    if (err.message.includes('ECONNREFUSED')) {
      console.error(`${c.red}Cannot connect to Chrome on ${CDP_HOST}:${CDP_PORT}${c.reset}`);
      console.error(`\nStart Chrome with: ${c.cyan}browser-open${c.reset}`);
    } else {
      console.error(`${c.red}Connection error: ${err.message}${c.reset}`);
    }
    process.exit(1);
  }
}

// Commands

async function cmdScreenshot(args) {
  const { execSync } = require('child_process');
  const { page, browser } = await connect();
  
  let selector = null;
  let fullPage = false;
  let filename = null;
  let maxDimension = 1500; // Default max dimension (under 2000px limit for AI models)
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--full' || args[i] === '-f') {
      fullPage = true;
    } else if (args[i] === '--selector' || args[i] === '-s') {
      selector = args[++i];
    } else if (args[i] === '--output' || args[i] === '-o') {
      filename = args[++i];
    } else if (args[i] === '--max' || args[i] === '-m') {
      maxDimension = parseInt(args[++i]);
    } else if (args[i] === '--no-resize') {
      maxDimension = null;
    } else if (!args[i].startsWith('-')) {
      selector = args[i];
    }
  }
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  filename = filename || path.join(SCREENSHOT_DIR, `screenshot-${timestamp}.png`);
  
  try {
    if (selector) {
      const element = await page.$(selector);
      if (!element) {
        console.error(`${c.red}Element not found: ${selector}${c.reset}`);
        await browser.close();
        process.exit(1);
      }
      await element.screenshot({ path: filename });
    } else {
      await page.screenshot({ path: filename, fullPage });
    }
    
    // Resize to max dimension if needed (keeps aspect ratio, uses macOS sips)
    if (maxDimension) {
      try {
        // Get current dimensions
        const info = execSync(`sips -g pixelWidth -g pixelHeight "${filename}" 2>/dev/null`, { encoding: 'utf8' });
        const width = parseInt(info.match(/pixelWidth:\s*(\d+)/)?.[1] || '0');
        const height = parseInt(info.match(/pixelHeight:\s*(\d+)/)?.[1] || '0');
        
        if (width > maxDimension || height > maxDimension) {
          // Resize to fit within maxDimension, maintaining aspect ratio
          execSync(`sips --resampleHeightWidthMax ${maxDimension} "${filename}" >/dev/null 2>&1`);
          console.log(`${c.dim}Resized to max ${maxDimension}px${c.reset}`);
        }
      } catch (e) {
        // sips not available or failed, continue without resize
      }
    }
    
    console.log(`${c.green}Screenshot saved:${c.reset} ${filename}`);
    console.log(`${c.dim}Page: ${page.url()}${c.reset}`);
  } finally {
    await browser.close();
  }
}

async function cmdLogs(args) {
  const LOG_FILE = process.env.BROWSER_LOG_FILE || '/tmp/browser-ctl-logs.jsonl';
  
  let level = null;
  let json = false;
  let follow = false;
  let lines = 50;  // default last N lines
  let clear = false;
  let all = false;
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--level' || args[i] === '-l') {
      level = args[++i];
    } else if (args[i] === '--json' || args[i] === '-j') {
      json = true;
    } else if (args[i] === '--follow' || args[i] === '-f') {
      follow = true;
    } else if (args[i] === '--lines' || args[i] === '-n') {
      lines = parseInt(args[++i]);
    } else if (args[i] === '--all' || args[i] === '-a') {
      all = true;
    } else if (args[i] === '--clear' || args[i] === '-c') {
      clear = true;
    }
  }
  
  // Clear log file if requested
  if (clear) {
    fs.writeFileSync(LOG_FILE, '');
    console.log(`${c.green}Logs cleared${c.reset}`);
    return;
  }
  
  // Check if log file exists
  if (!fs.existsSync(LOG_FILE)) {
    console.error(`${c.red}No log file found at ${LOG_FILE}${c.reset}`);
    console.error(`\nStart Chrome with: ${c.cyan}browser-open${c.reset}`);
    process.exit(1);
  }
  
  const levels = ['debug', 'log', 'info', 'warn', 'error'];
  const minLevel = level ? levels.indexOf(level) : 0;
  
  function shouldShow(msgLevel) {
    const idx = levels.indexOf(msgLevel);
    return idx >= minLevel;
  }
  
  function formatLevel(lvl) {
    const colors = { error: c.red, warn: c.yellow, info: c.blue, debug: c.gray, log: c.reset };
    return (colors[lvl] || c.reset) + lvl.toUpperCase().padEnd(5) + c.reset;
  }
  
  function formatEntry(entry) {
    if (json) {
      console.log(JSON.stringify(entry));
      return;
    }
    
    // Skip collector meta messages unless showing all
    if (entry.type === 'collector' && !all) return;
    
    const ts = c.dim + (entry.ts || '').split('T')[1]?.slice(0, 12) || '' + c.reset;
    const lvl = formatLevel(entry.level);
    const loc = entry.url ? ` ${c.dim}(${path.basename(entry.url)}${entry.line ? ':' + entry.line : ''})${c.reset}` : '';
    const typeTag = entry.type && entry.type !== 'collector' ? `${c.dim}[${entry.type.toUpperCase()}]${c.reset} ` : '';
    
    console.log(`${ts} ${lvl} ${typeTag}${entry.message}${loc}`);
  }
  
  // Read and display existing logs
  const content = fs.readFileSync(LOG_FILE, 'utf8');
  const allLines = content.trim().split('\n').filter(Boolean);
  
  // Get last N lines (or all if --all)
  const linesToShow = all ? allLines : allLines.slice(-lines);
  
  let shown = 0;
  for (const line of linesToShow) {
    try {
      const entry = JSON.parse(line);
      if (!shouldShow(entry.level)) continue;
      formatEntry(entry);
      shown++;
    } catch (e) {
      // Skip malformed lines
    }
  }
  
  if (!json && !follow) {
    if (shown === 0) {
      console.log(`${c.dim}No logs found${level ? ` at level '${level}' or above` : ''}${c.reset}`);
    } else {
      console.log(`${c.dim}─── Showing ${shown} of ${allLines.length} entries ───${c.reset}`);
    }
  }
  
  // Follow mode - tail the file
  if (follow) {
    if (!json) {
      console.log(`${c.cyan}● Following logs...${c.reset} ${c.dim}(Ctrl+C to stop)${c.reset}\n`);
    }
    
    let lastSize = fs.statSync(LOG_FILE).size;
    
    const watcher = setInterval(() => {
      try {
        const stats = fs.statSync(LOG_FILE);
        if (stats.size > lastSize) {
          // Read new content
          const fd = fs.openSync(LOG_FILE, 'r');
          const buffer = Buffer.alloc(stats.size - lastSize);
          fs.readSync(fd, buffer, 0, buffer.length, lastSize);
          fs.closeSync(fd);
          
          const newLines = buffer.toString().trim().split('\n').filter(Boolean);
          for (const line of newLines) {
            try {
              const entry = JSON.parse(line);
              if (!shouldShow(entry.level)) continue;
              formatEntry(entry);
            } catch (e) {}
          }
          
          lastSize = stats.size;
        } else if (stats.size < lastSize) {
          // File was truncated/rotated
          lastSize = stats.size;
        }
      } catch (e) {
        // File might be temporarily unavailable
      }
    }, 200);
    
    process.on('SIGINT', () => {
      clearInterval(watcher);
      if (!json) console.log(`\n${c.dim}Stopped.${c.reset}`);
      process.exit(0);
    });
    
    // Keep running
    await new Promise(() => {});
  }
}

async function cmdClick(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  if (!selector) {
    console.error(`${c.red}Usage: browser-ctl click <selector>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    await page.click(selector, { timeout: 5000 });
    console.log(`${c.green}Clicked:${c.reset} ${selector}`);
  } catch (err) {
    console.error(`${c.red}Click failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdType(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  const text = args.slice(1).join(' ');
  
  if (!selector || !text) {
    console.error(`${c.red}Usage: browser-ctl type <selector> <text>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    await page.fill(selector, text, { timeout: 5000 });
    console.log(`${c.green}Typed into ${selector}:${c.reset} "${text}"`);
  } catch (err) {
    console.error(`${c.red}Type failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdGoto(args) {
  const { page, browser } = await connect();
  
  let url = args[0];
  if (!url) {
    console.error(`${c.red}Usage: browser-ctl goto <url>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  // Handle relative URLs
  if (url.startsWith('/')) {
    const currentUrl = new URL(page.url());
    url = `${currentUrl.origin}${url}`;
  }
  
  try {
    await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
    console.log(`${c.green}Navigated to:${c.reset} ${page.url()}`);
  } catch (err) {
    console.error(`${c.red}Navigation failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdEval(args) {
  const { page, browser } = await connect();
  
  const script = args.join(' ');
  if (!script) {
    console.error(`${c.red}Usage: browser-ctl eval <javascript>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    const result = await page.evaluate(script);
    if (typeof result === 'object') {
      console.log(JSON.stringify(result, null, 2));
    } else {
      console.log(result);
    }
  } catch (err) {
    console.error(`${c.red}Eval failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdHtml(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  
  try {
    let html;
    if (selector) {
      const element = await page.$(selector);
      if (!element) {
        console.error(`${c.red}Element not found: ${selector}${c.reset}`);
        await browser.close();
        process.exit(1);
      }
      html = await element.innerHTML();
    } else {
      html = await page.content();
    }
    console.log(html);
  } catch (err) {
    console.error(`${c.red}HTML fetch failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdSnapshot(args) {
  const { page, browser } = await connect();
  
  try {
    // Get accessibility tree - similar to Cursor's browser_snapshot
    const snapshot = await page.accessibility.snapshot({ interestingOnly: true });
    console.log(JSON.stringify(snapshot, null, 2));
  } catch (err) {
    console.error(`${c.red}Snapshot failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdUrl(args) {
  const { page, browser } = await connect();
  console.log(page.url());
  await browser.close();
}

async function cmdTitle(args) {
  const { page, browser } = await connect();
  console.log(await page.title());
  await browser.close();
}

async function cmdWait(args) {
  const { page, browser } = await connect();
  
  const target = args[0];
  const timeout = parseInt(args[1]) || 30000;
  
  if (!target) {
    console.error(`${c.red}Usage: browser-ctl wait <selector|url:pattern|text:content> [timeout_ms]${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    if (target.startsWith('url:')) {
      const pattern = target.slice(4);
      await page.waitForURL(`**${pattern}**`, { timeout });
    } else if (target.startsWith('text:')) {
      const text = target.slice(5);
      await page.waitForSelector(`text=${text}`, { timeout });
    } else {
      await page.waitForSelector(target, { timeout });
    }
    console.log(`${c.green}Wait complete:${c.reset} ${target}`);
  } catch (err) {
    console.error(`${c.red}Wait failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdReload(args) {
  const { page, browser } = await connect();
  
  try {
    await page.reload({ waitUntil: 'domcontentloaded' });
    console.log(`${c.green}Reloaded:${c.reset} ${page.url()}`);
  } catch (err) {
    console.error(`${c.red}Reload failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdTabs(args) {
  const { browser, contexts } = await connect();
  
  const allPages = contexts.flatMap(ctx => ctx.pages());
  console.log(`${c.cyan}Open tabs (${allPages.length}):${c.reset}`);
  for (let i = 0; i < allPages.length; i++) {
    const p = allPages[i];
    const title = await p.title();
    console.log(`  ${i}: ${title || '(no title)'}`);
    console.log(`     ${c.dim}${p.url()}${c.reset}`);
  }
  
  await browser.close();
}

async function cmdTab(args) {
  const { browser, contexts } = await connect();
  
  const index = parseInt(args[0]);
  if (isNaN(index)) {
    console.error(`${c.red}Usage: browser-ctl tab <index>${c.reset}`);
    console.error(`Use 'browser-ctl tabs' to see available tabs`);
    await browser.close();
    process.exit(1);
  }
  
  const allPages = contexts.flatMap(ctx => ctx.pages());
  if (index < 0 || index >= allPages.length) {
    console.error(`${c.red}Invalid tab index: ${index}${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  const targetPage = allPages[index];
  await targetPage.bringToFront();
  console.log(`${c.green}Switched to tab ${index}:${c.reset} ${await targetPage.title()}`);
  
  await browser.close();
}

// Help
function showHelp() {
  console.log(`
${c.cyan}browser-ctl${c.reset} - Control browser via Playwright + CDP

${c.yellow}USAGE${c.reset}
  browser-ctl <command> [options]

${c.yellow}COMMANDS${c.reset}
  ${c.green}screenshot${c.reset} [selector] [--full] [-o file] [--max N] [--no-resize]
      Take screenshot of page or element
      Auto-resizes to 1500px max (AI-friendly). Use --no-resize to disable.
      
  ${c.green}logs${c.reset} [--level LEVEL] [--json] [-n LINES] [--follow] [--clear]
      Show console logs from log file (collected by browser-open daemon)
      -n, --lines N    Show last N lines (default: 50)
      -a, --all        Show all logs
      -f, --follow     Tail the log file (like tail -f)
      -c, --clear      Clear the log file
      Levels: debug, log, info, warn, error
      
  ${c.green}click${c.reset} <selector>
      Click an element
      
  ${c.green}type${c.reset} <selector> <text>
      Type text into an input
      
  ${c.green}goto${c.reset} <url>
      Navigate to URL (supports relative paths like /accounts)
      
  ${c.green}eval${c.reset} <javascript>
      Execute JavaScript and print result
      
  ${c.green}html${c.reset} [selector]
      Get HTML content of page or element
      
  ${c.green}snapshot${c.reset}
      Get accessibility tree (like Cursor's browser_snapshot)
      
  ${c.green}url${c.reset}
      Print current URL
      
  ${c.green}title${c.reset}
      Print page title
      
  ${c.green}wait${c.reset} <selector|url:pattern|text:content> [timeout]
      Wait for element, URL, or text
      
  ${c.green}reload${c.reset}
      Reload current page
      
  ${c.green}tabs${c.reset}
      List all open tabs
      
  ${c.green}tab${c.reset} <index>
      Switch to tab by index

${c.yellow}EXAMPLES${c.reset}
  browser-ctl screenshot --full
  browser-ctl logs                        # Last 50 log entries
  browser-ctl logs --level error          # Only errors
  browser-ctl logs -n 100 --json          # Last 100 as JSON
  browser-ctl logs --follow               # Tail logs (like tail -f)
  browser-ctl click "button[type=submit]"
  browser-ctl type "#search" "hello world"
  browser-ctl goto /accounts
  browser-ctl eval "document.querySelectorAll('button').length"
  browser-ctl wait "text:Loading" 10000
  browser-ctl html ".sidebar"

${c.yellow}ENVIRONMENT${c.reset}
  CDP_PORT         Chrome debugging port (default: 9222)
  CDP_HOST         Chrome host (default: localhost)
  SCREENSHOT_DIR   Screenshot output directory (default: /tmp/browser-ctl)

${c.yellow}SETUP${c.reset}
  First, launch Chrome with debugging enabled:
    ${c.cyan}browser-open${c.reset}
  
  Then use browser-ctl commands to interact with it.
`);
}

// Main
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  const cmdArgs = args.slice(1);
  
  if (!command || command === '--help' || command === '-h') {
    showHelp();
    process.exit(0);
  }
  
  switch (command) {
    case 'screenshot':
    case 'ss':
      await cmdScreenshot(cmdArgs);
      break;
    case 'logs':
    case 'log':
      await cmdLogs(cmdArgs);
      break;
    case 'click':
      await cmdClick(cmdArgs);
      break;
    case 'type':
      await cmdType(cmdArgs);
      break;
    case 'goto':
    case 'go':
      await cmdGoto(cmdArgs);
      break;
    case 'eval':
    case 'js':
      await cmdEval(cmdArgs);
      break;
    case 'html':
      await cmdHtml(cmdArgs);
      break;
    case 'snapshot':
    case 'snap':
      await cmdSnapshot(cmdArgs);
      break;
    case 'url':
      await cmdUrl(cmdArgs);
      break;
    case 'title':
      await cmdTitle(cmdArgs);
      break;
    case 'wait':
      await cmdWait(cmdArgs);
      break;
    case 'reload':
      await cmdReload(cmdArgs);
      break;
    case 'tabs':
      await cmdTabs(cmdArgs);
      break;
    case 'tab':
      await cmdTab(cmdArgs);
      break;
    default:
      console.error(`${c.red}Unknown command: ${command}${c.reset}`);
      console.error(`Run 'browser-ctl --help' for usage`);
      process.exit(1);
  }
}

main().catch(err => {
  console.error(`${c.red}Error: ${err.message}${c.reset}`);
  process.exit(1);
});
