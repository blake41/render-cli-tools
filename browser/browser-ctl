#!/usr/bin/env node
/**
 * browser-ctl - Control browser via Playwright + CDP
 * 
 * Connects to Chrome with remote debugging and provides full control:
 * - Screenshots
 * - Console logs
 * - Click, type, navigate
 * - JavaScript evaluation
 * - Accessibility snapshots
 * 
 * Usage:
 *   browser-ctl screenshot                    # Screenshot current page
 *   browser-ctl logs                          # Stream console logs
 *   browser-ctl click "button.submit"         # Click element
 *   browser-ctl goto "/accounts"              # Navigate
 *   browser-ctl eval "document.title"         # Run JS
 */

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

// Config
const CDP_PORT = process.env.CDP_PORT || 9222;
const CDP_HOST = process.env.CDP_HOST || 'localhost';
const SCREENSHOT_DIR = process.env.SCREENSHOT_DIR || '/tmp/browser-ctl';

// ANSI colors
const c = {
  reset: '\x1b[0m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
};

// Ensure screenshot directory exists
if (!fs.existsSync(SCREENSHOT_DIR)) {
  fs.mkdirSync(SCREENSHOT_DIR, { recursive: true });
}

async function connect() {
  try {
    const browser = await chromium.connectOverCDP(`http://${CDP_HOST}:${CDP_PORT}`);
    const contexts = browser.contexts();
    if (contexts.length === 0) {
      console.error(`${c.red}No browser contexts found${c.reset}`);
      process.exit(1);
    }
    const pages = contexts[0].pages();
    if (pages.length === 0) {
      console.error(`${c.red}No pages found${c.reset}`);
      process.exit(1);
    }
    return { browser, page: pages[0], contexts };
  } catch (err) {
    if (err.message.includes('ECONNREFUSED')) {
      console.error(`${c.red}Cannot connect to Chrome on ${CDP_HOST}:${CDP_PORT}${c.reset}`);
      console.error(`\nStart Chrome with: ${c.cyan}browser-open${c.reset}`);
    } else {
      console.error(`${c.red}Connection error: ${err.message}${c.reset}`);
    }
    process.exit(1);
  }
}

// Commands

async function cmdScreenshot(args) {
  const { execSync } = require('child_process');
  const { page, browser } = await connect();
  
  let selector = null;
  let fullPage = false;
  let filename = null;
  let maxDimension = 1500; // Default max dimension (under 2000px limit for AI models)
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--full' || args[i] === '-f') {
      fullPage = true;
    } else if (args[i] === '--selector' || args[i] === '-s') {
      selector = args[++i];
    } else if (args[i] === '--output' || args[i] === '-o') {
      filename = args[++i];
    } else if (args[i] === '--max' || args[i] === '-m') {
      maxDimension = parseInt(args[++i]);
    } else if (args[i] === '--no-resize') {
      maxDimension = null;
    } else if (!args[i].startsWith('-')) {
      selector = args[i];
    }
  }
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  filename = filename || path.join(SCREENSHOT_DIR, `screenshot-${timestamp}.png`);
  
  try {
    if (selector) {
      const element = await page.$(selector);
      if (!element) {
        console.error(`${c.red}Element not found: ${selector}${c.reset}`);
        await browser.close();
        process.exit(1);
      }
      await element.screenshot({ path: filename });
    } else {
      await page.screenshot({ path: filename, fullPage });
    }
    
    // Resize to max dimension if needed (keeps aspect ratio, uses macOS sips)
    if (maxDimension) {
      try {
        // Get current dimensions
        const info = execSync(`sips -g pixelWidth -g pixelHeight "${filename}" 2>/dev/null`, { encoding: 'utf8' });
        const width = parseInt(info.match(/pixelWidth:\s*(\d+)/)?.[1] || '0');
        const height = parseInt(info.match(/pixelHeight:\s*(\d+)/)?.[1] || '0');
        
        if (width > maxDimension || height > maxDimension) {
          // Resize to fit within maxDimension, maintaining aspect ratio
          execSync(`sips --resampleHeightWidthMax ${maxDimension} "${filename}" >/dev/null 2>&1`);
          console.log(`${c.dim}Resized to max ${maxDimension}px${c.reset}`);
        }
      } catch (e) {
        // sips not available or failed, continue without resize
      }
    }
    
    console.log(`${c.green}Screenshot saved:${c.reset} ${filename}`);
    console.log(`${c.dim}Page: ${page.url()}${c.reset}`);
  } finally {
    await browser.close();
  }
}

async function cmdLogs(args) {
  const LOG_FILE = process.env.BROWSER_LOG_FILE || '/tmp/browser-ctl-logs.jsonl';
  
  let level = null;
  let json = false;
  let follow = false;
  let lines = 50;  // default last N lines
  let clear = false;
  let all = false;
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--level' || args[i] === '-l') {
      level = args[++i];
    } else if (args[i] === '--json' || args[i] === '-j') {
      json = true;
    } else if (args[i] === '--follow' || args[i] === '-f') {
      follow = true;
    } else if (args[i] === '--lines' || args[i] === '-n') {
      lines = parseInt(args[++i]);
    } else if (args[i] === '--all' || args[i] === '-a') {
      all = true;
    } else if (args[i] === '--clear' || args[i] === '-c') {
      clear = true;
    }
  }
  
  // Clear log file if requested
  if (clear) {
    fs.writeFileSync(LOG_FILE, '');
    console.log(`${c.green}Logs cleared${c.reset}`);
    return;
  }
  
  // Check if log file exists
  if (!fs.existsSync(LOG_FILE)) {
    console.error(`${c.red}No log file found at ${LOG_FILE}${c.reset}`);
    console.error(`\nStart Chrome with: ${c.cyan}browser-open${c.reset}`);
    process.exit(1);
  }
  
  const levels = ['debug', 'log', 'info', 'warn', 'error'];
  const minLevel = level ? levels.indexOf(level) : 0;
  
  function shouldShow(msgLevel) {
    const idx = levels.indexOf(msgLevel);
    return idx >= minLevel;
  }
  
  function formatLevel(lvl) {
    const colors = { error: c.red, warn: c.yellow, info: c.blue, debug: c.gray, log: c.reset };
    return (colors[lvl] || c.reset) + lvl.toUpperCase().padEnd(5) + c.reset;
  }
  
  function formatEntry(entry) {
    if (json) {
      console.log(JSON.stringify(entry));
      return;
    }
    
    // Skip collector meta messages unless showing all
    if (entry.type === 'collector' && !all) return;
    
    const ts = c.dim + (entry.ts || '').split('T')[1]?.slice(0, 12) || '' + c.reset;
    const lvl = formatLevel(entry.level);
    const loc = entry.url ? ` ${c.dim}(${path.basename(entry.url)}${entry.line ? ':' + entry.line : ''})${c.reset}` : '';
    const typeTag = entry.type && entry.type !== 'collector' ? `${c.dim}[${entry.type.toUpperCase()}]${c.reset} ` : '';
    
    console.log(`${ts} ${lvl} ${typeTag}${entry.message}${loc}`);
  }
  
  // Read and display existing logs
  const content = fs.readFileSync(LOG_FILE, 'utf8');
  const allLines = content.trim().split('\n').filter(Boolean);
  
  // Get last N lines (or all if --all)
  const linesToShow = all ? allLines : allLines.slice(-lines);
  
  let shown = 0;
  for (const line of linesToShow) {
    try {
      const entry = JSON.parse(line);
      if (!shouldShow(entry.level)) continue;
      formatEntry(entry);
      shown++;
    } catch (e) {
      // Skip malformed lines
    }
  }
  
  if (!json && !follow) {
    if (shown === 0) {
      console.log(`${c.dim}No logs found${level ? ` at level '${level}' or above` : ''}${c.reset}`);
    } else {
      console.log(`${c.dim}─── Showing ${shown} of ${allLines.length} entries ───${c.reset}`);
    }
  }
  
  // Follow mode - tail the file
  if (follow) {
    if (!json) {
      console.log(`${c.cyan}● Following logs...${c.reset} ${c.dim}(Ctrl+C to stop)${c.reset}\n`);
    }
    
    let lastSize = fs.statSync(LOG_FILE).size;
    
    const watcher = setInterval(() => {
      try {
        const stats = fs.statSync(LOG_FILE);
        if (stats.size > lastSize) {
          // Read new content
          const fd = fs.openSync(LOG_FILE, 'r');
          const buffer = Buffer.alloc(stats.size - lastSize);
          fs.readSync(fd, buffer, 0, buffer.length, lastSize);
          fs.closeSync(fd);
          
          const newLines = buffer.toString().trim().split('\n').filter(Boolean);
          for (const line of newLines) {
            try {
              const entry = JSON.parse(line);
              if (!shouldShow(entry.level)) continue;
              formatEntry(entry);
            } catch (e) {}
          }
          
          lastSize = stats.size;
        } else if (stats.size < lastSize) {
          // File was truncated/rotated
          lastSize = stats.size;
        }
      } catch (e) {
        // File might be temporarily unavailable
      }
    }, 200);
    
    process.on('SIGINT', () => {
      clearInterval(watcher);
      if (!json) console.log(`\n${c.dim}Stopped.${c.reset}`);
      process.exit(0);
    });
    
    // Keep running
    await new Promise(() => {});
  }
}

async function cmdClick(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  if (!selector) {
    console.error(`${c.red}Usage: browser-ctl click <selector>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    await page.click(selector, { timeout: 5000 });
    console.log(`${c.green}Clicked:${c.reset} ${selector}`);
  } catch (err) {
    console.error(`${c.red}Click failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdType(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  const text = args.slice(1).join(' ');
  
  if (!selector || !text) {
    console.error(`${c.red}Usage: browser-ctl type <selector> <text>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    await page.fill(selector, text, { timeout: 5000 });
    console.log(`${c.green}Typed into ${selector}:${c.reset} "${text}"`);
  } catch (err) {
    console.error(`${c.red}Type failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdGoto(args) {
  const { page, browser } = await connect();
  
  let url = args[0];
  if (!url) {
    console.error(`${c.red}Usage: browser-ctl goto <url>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  // Handle relative URLs
  if (url.startsWith('/')) {
    const currentUrl = new URL(page.url());
    url = `${currentUrl.origin}${url}`;
  }
  
  try {
    await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
    console.log(`${c.green}Navigated to:${c.reset} ${page.url()}`);
  } catch (err) {
    console.error(`${c.red}Navigation failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdEval(args) {
  const { page, browser } = await connect();
  
  const script = args.join(' ');
  if (!script) {
    console.error(`${c.red}Usage: browser-ctl eval <javascript>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    const result = await page.evaluate(script);
    if (typeof result === 'object') {
      console.log(JSON.stringify(result, null, 2));
    } else {
      console.log(result);
    }
  } catch (err) {
    console.error(`${c.red}Eval failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdHtml(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  
  try {
    let html;
    if (selector) {
      const element = await page.$(selector);
      if (!element) {
        console.error(`${c.red}Element not found: ${selector}${c.reset}`);
        await browser.close();
        process.exit(1);
      }
      html = await element.innerHTML();
    } else {
      html = await page.content();
    }
    console.log(html);
  } catch (err) {
    console.error(`${c.red}HTML fetch failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdSnapshot(args) {
  const { page, browser } = await connect();
  
  try {
    // Get accessibility tree - similar to Cursor's browser_snapshot
    const snapshot = await page.accessibility.snapshot({ interestingOnly: true });
    console.log(JSON.stringify(snapshot, null, 2));
  } catch (err) {
    console.error(`${c.red}Snapshot failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdUrl(args) {
  const { page, browser } = await connect();
  console.log(page.url());
  await browser.close();
}

async function cmdTitle(args) {
  const { page, browser } = await connect();
  console.log(await page.title());
  await browser.close();
}

async function cmdWait(args) {
  const { page, browser } = await connect();
  
  const target = args[0];
  const timeout = parseInt(args[1]) || 30000;
  
  if (!target) {
    console.error(`${c.red}Usage: browser-ctl wait <selector|url:pattern|text:content> [timeout_ms]${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    if (target.startsWith('url:')) {
      const pattern = target.slice(4);
      await page.waitForURL(`**${pattern}**`, { timeout });
    } else if (target.startsWith('text:')) {
      const text = target.slice(5);
      await page.waitForSelector(`text=${text}`, { timeout });
    } else {
      await page.waitForSelector(target, { timeout });
    }
    console.log(`${c.green}Wait complete:${c.reset} ${target}`);
  } catch (err) {
    console.error(`${c.red}Wait failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdReload(args) {
  const { page, browser } = await connect();
  
  try {
    await page.reload({ waitUntil: 'domcontentloaded' });
    console.log(`${c.green}Reloaded:${c.reset} ${page.url()}`);
  } catch (err) {
    console.error(`${c.red}Reload failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdTabs(args) {
  const { browser, contexts } = await connect();
  
  const allPages = contexts.flatMap(ctx => ctx.pages());
  console.log(`${c.cyan}Open tabs (${allPages.length}):${c.reset}`);
  for (let i = 0; i < allPages.length; i++) {
    const p = allPages[i];
    const title = await p.title();
    console.log(`  ${i}: ${title || '(no title)'}`);
    console.log(`     ${c.dim}${p.url()}${c.reset}`);
  }
  
  await browser.close();
}

async function cmdTab(args) {
  const { browser, contexts } = await connect();
  
  const index = parseInt(args[0]);
  if (isNaN(index)) {
    console.error(`${c.red}Usage: browser-ctl tab <index>${c.reset}`);
    console.error(`Use 'browser-ctl tabs' to see available tabs`);
    await browser.close();
    process.exit(1);
  }
  
  const allPages = contexts.flatMap(ctx => ctx.pages());
  if (index < 0 || index >= allPages.length) {
    console.error(`${c.red}Invalid tab index: ${index}${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  const targetPage = allPages[index];
  await targetPage.bringToFront();
  console.log(`${c.green}Switched to tab ${index}:${c.reset} ${await targetPage.title()}`);
  
  await browser.close();
}

// Test runner
async function cmdTest(args) {
  // Check for help flag first
  if (args.includes('--help') || args.includes('-h') || args.length === 0) {
    console.log(`
${c.cyan}browser-ctl test${c.reset} - Run browser tests from YAML/JSON specs

${c.yellow}USAGE${c.reset}
  browser-ctl test <file.yaml|directory> [options]

${c.yellow}OPTIONS${c.reset}
  --verbose, -v     Show detailed step-by-step output
  --json            Output results as JSON
  --junit=FILE      Write JUnit XML report to FILE
  --bail            Stop on first test failure
  --filter=PATTERN  Only run tests with names matching PATTERN

${c.yellow}EXAMPLES${c.reset}
  browser-ctl test tests/browser/auth.yaml
  browser-ctl test tests/browser/
  browser-ctl test tests/ --verbose
  browser-ctl test tests/ --junit=results.xml
  browser-ctl test tests/ --filter="login"

${c.yellow}TEST FILE FORMAT (YAML)${c.reset}
  name: My Test Suite
  setup:
    - goto: "http://localhost:5173"
    - wait: "[data-testid='app']"
  
  tests:
    - name: Login works
      steps:
        - click: "[data-testid='login-button']"
        - type:
            selector: "#email"
            text: "test@example.com"
        - click: "[data-testid='submit']"
        - wait: "[data-testid='dashboard']"
      assertions:
        - visible: "[data-testid='dashboard']"
        - url-includes: "/dashboard"

${c.yellow}AVAILABLE STEPS${c.reset}
  goto: <url>                    Navigate to URL
  click: <selector>              Click element
  type: { selector, text }       Type into input
  wait: <selector|number>        Wait for element or milliseconds
  sleep: <ms>                    Wait for milliseconds
  screenshot: [name]             Take screenshot
  eval: <javascript>             Execute JavaScript
  reload:                        Reload page

${c.yellow}AVAILABLE ASSERTIONS${c.reset}
  visible: <selector>            Element is visible
  hidden: <selector>             Element is hidden
  contains: { selector, text }   Element contains text
  url: <exact-url>               URL equals exactly
  url-includes: <substring>      URL contains substring
  url-matches: <regex>           URL matches regex
  count: { selector, equals|min|max }  Element count
  attribute: { selector, name, equals|includes }  Attribute value
`);
    process.exit(0);
  }
  
  // Parse arguments
  let testPath = args.find(a => !a.startsWith('-'));
  let verbose = args.includes('--verbose') || args.includes('-v');
  let jsonOutput = args.includes('--json');
  let junitOutput = args.find(a => a.startsWith('--junit='))?.split('=')[1];
  let bail = args.includes('--bail');
  let filter = args.find(a => a.startsWith('--filter='))?.split('=')[1];
  
  if (!testPath) {
    console.error(`${c.red}Usage: browser-ctl test <file.yaml|directory> [options]${c.reset}`);
    console.error(`Run 'browser-ctl test --help' for more information.`);
    process.exit(1);
  }
  
  // Collect test files
  let testFiles = [];
  const stat = fs.statSync(testPath);
  if (stat.isDirectory()) {
    const files = fs.readdirSync(testPath);
    testFiles = files
      .filter(f => f.endsWith('.yaml') || f.endsWith('.yml') || f.endsWith('.json'))
      .map(f => path.join(testPath, f));
  } else {
    testFiles = [testPath];
  }
  
  if (testFiles.length === 0) {
    console.error(`${c.red}No test files found${c.reset}`);
    process.exit(1);
  }
  
  // Results accumulator
  const allResults = {
    suites: [],
    totalTests: 0,
    passed: 0,
    failed: 0,
    skipped: 0,
    duration: 0
  };
  
  const startTime = Date.now();
  
  // Connect once for all tests
  const { browser, page } = await connect();
  
  for (const file of testFiles) {
    const content = fs.readFileSync(file, 'utf8');
    let suite;
    
    try {
      suite = file.endsWith('.json') ? JSON.parse(content) : yaml.load(content);
    } catch (err) {
      console.error(`${c.red}Failed to parse ${file}: ${err.message}${c.reset}`);
      continue;
    }
    
    const suiteResult = await runTestSuite(page, suite, { verbose, bail, filter, file });
    allResults.suites.push(suiteResult);
    allResults.totalTests += suiteResult.tests.length;
    allResults.passed += suiteResult.passed;
    allResults.failed += suiteResult.failed;
    allResults.skipped += suiteResult.skipped;
    
    if (bail && suiteResult.failed > 0) break;
  }
  
  allResults.duration = Date.now() - startTime;
  
  await browser.close();
  
  // Output results
  if (jsonOutput) {
    console.log(JSON.stringify(allResults, null, 2));
  } else if (junitOutput) {
    const junit = generateJUnitXml(allResults);
    fs.writeFileSync(junitOutput, junit);
    console.log(`${c.green}JUnit report written to:${c.reset} ${junitOutput}`);
    printSummary(allResults);
  } else {
    printSummary(allResults);
  }
  
  process.exit(allResults.failed > 0 ? 1 : 0);
}

async function runTestSuite(page, suite, opts) {
  const { verbose, bail, filter, file } = opts;
  const suiteName = suite.name || path.basename(file, path.extname(file));
  
  if (!opts.jsonOutput) {
    console.log(`\n${c.cyan}▶ ${suiteName}${c.reset}`);
  }
  
  const result = {
    name: suiteName,
    file,
    tests: [],
    passed: 0,
    failed: 0,
    skipped: 0,
    duration: 0
  };
  
  const suiteStart = Date.now();
  
  // Run setup steps
  if (suite.setup) {
    try {
      await runSteps(page, suite.setup, verbose);
    } catch (err) {
      console.error(`${c.red}  Setup failed: ${err.message}${c.reset}`);
      result.failed = (suite.tests || []).length;
      return result;
    }
  }
  
  // Run each test
  for (const test of (suite.tests || [])) {
    const testName = test.name || 'Unnamed test';
    
    // Apply filter
    if (filter && !testName.toLowerCase().includes(filter.toLowerCase())) {
      result.skipped++;
      result.tests.push({ name: testName, status: 'skipped' });
      continue;
    }
    
    const testStart = Date.now();
    const testResult = { name: testName, status: 'passed', duration: 0, error: null };
    
    try {
      // Run test steps
      if (test.steps) {
        await runSteps(page, test.steps, verbose);
      }
      
      // Run assertions
      if (test.assertions) {
        await runAssertions(page, test.assertions, verbose);
      }
      
      testResult.status = 'passed';
      result.passed++;
      if (!opts.jsonOutput) {
        console.log(`  ${c.green}✓${c.reset} ${testName}`);
      }
    } catch (err) {
      testResult.status = 'failed';
      testResult.error = err.message;
      result.failed++;
      if (!opts.jsonOutput) {
        console.log(`  ${c.red}✗${c.reset} ${testName}`);
        console.log(`    ${c.dim}${err.message}${c.reset}`);
      }
      
      // Take failure screenshot
      try {
        const screenshotPath = path.join(SCREENSHOT_DIR, `failure-${Date.now()}.png`);
        await page.screenshot({ path: screenshotPath });
        testResult.screenshot = screenshotPath;
        if (verbose) {
          console.log(`    ${c.dim}Screenshot: ${screenshotPath}${c.reset}`);
        }
      } catch (e) {}
      
      if (bail) break;
    }
    
    testResult.duration = Date.now() - testStart;
    result.tests.push(testResult);
  }
  
  result.duration = Date.now() - suiteStart;
  return result;
}

async function runSteps(page, steps, verbose) {
  for (const step of steps) {
    // Each step is an object like { goto: "/path" } or { click: "selector" }
    const [action, value] = Object.entries(step)[0];
    
    if (verbose) {
      console.log(`    ${c.dim}→ ${action}: ${JSON.stringify(value)}${c.reset}`);
    }
    
    switch (action) {
      case 'goto':
        let url = value;
        if (url.startsWith('/')) {
          const currentUrl = new URL(page.url());
          url = `${currentUrl.origin}${url}`;
        }
        await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
        break;
        
      case 'click':
        await page.click(value, { timeout: 10000 });
        break;
        
      case 'type':
        // { type: { selector: "#input", text: "hello" } }
        await page.fill(value.selector, value.text, { timeout: 10000 });
        break;
        
      case 'wait':
        if (typeof value === 'number') {
          await page.waitForTimeout(value);
        } else if (value.startsWith('url:')) {
          await page.waitForURL(`**${value.slice(4)}**`, { timeout: 30000 });
        } else {
          await page.waitForSelector(value, { timeout: 30000 });
        }
        break;
        
      case 'screenshot':
        const screenshotPath = typeof value === 'string' 
          ? path.join(SCREENSHOT_DIR, value + '.png')
          : path.join(SCREENSHOT_DIR, `step-${Date.now()}.png`);
        await page.screenshot({ path: screenshotPath });
        if (verbose) console.log(`      ${c.dim}Saved: ${screenshotPath}${c.reset}`);
        break;
        
      case 'eval':
        await page.evaluate(value);
        break;
        
      case 'reload':
        await page.reload({ waitUntil: 'domcontentloaded' });
        break;
        
      case 'sleep':
        await page.waitForTimeout(value);
        break;
        
      default:
        throw new Error(`Unknown step action: ${action}`);
    }
  }
}

async function runAssertions(page, assertions, verbose) {
  for (const assertion of assertions) {
    const [type, value] = Object.entries(assertion)[0];
    
    // Run the assertion first, then log on success
    switch (type) {
      case 'visible':
        const visibleEl = await page.$(value);
        if (!visibleEl) {
          throw new Error(`Element not found: ${value}`);
        }
        const isVisible = await visibleEl.isVisible();
        if (!isVisible) {
          throw new Error(`Element not visible: ${value}`);
        }
        break;
        
      case 'hidden':
        const hiddenEl = await page.$(value);
        if (hiddenEl && await hiddenEl.isVisible()) {
          throw new Error(`Element should be hidden: ${value}`);
        }
        break;
        
      case 'contains':
        // { contains: { selector: "h1", text: "Hello" } }
        const containsEl = await page.$(value.selector);
        if (!containsEl) {
          throw new Error(`Element not found: ${value.selector}`);
        }
        const text = await containsEl.textContent();
        if (!text.includes(value.text)) {
          throw new Error(`Element "${value.selector}" does not contain "${value.text}". Found: "${text.substring(0, 100)}"`);
        }
        break;
        
      case 'url':
        const currentUrl = page.url();
        if (currentUrl !== value) {
          throw new Error(`URL mismatch. Expected: ${value}, Got: ${currentUrl}`);
        }
        break;
        
      case 'url-includes':
        if (!page.url().includes(value)) {
          throw new Error(`URL should include "${value}". Got: ${page.url()}`);
        }
        break;
        
      case 'url-matches':
        if (!new RegExp(value).test(page.url())) {
          throw new Error(`URL should match "${value}". Got: ${page.url()}`);
        }
        break;
        
      case 'count':
        // { count: { selector: ".item", min: 1, max: 10 } } or { count: { selector: ".item", equals: 5 } }
        const elements = await page.$$(value.selector);
        const count = elements.length;
        if (value.equals !== undefined && count !== value.equals) {
          throw new Error(`Expected ${value.equals} elements for "${value.selector}", found ${count}`);
        }
        if (value.min !== undefined && count < value.min) {
          throw new Error(`Expected at least ${value.min} elements for "${value.selector}", found ${count}`);
        }
        if (value.max !== undefined && count > value.max) {
          throw new Error(`Expected at most ${value.max} elements for "${value.selector}", found ${count}`);
        }
        break;
        
      case 'attribute':
        // { attribute: { selector: "input", name: "value", equals: "hello" } }
        const attrEl = await page.$(value.selector);
        if (!attrEl) {
          throw new Error(`Element not found: ${value.selector}`);
        }
        const attrValue = await attrEl.getAttribute(value.name);
        if (value.equals !== undefined && attrValue !== value.equals) {
          throw new Error(`Attribute "${value.name}" of "${value.selector}" should be "${value.equals}", got "${attrValue}"`);
        }
        if (value.includes !== undefined && (!attrValue || !attrValue.includes(value.includes))) {
          throw new Error(`Attribute "${value.name}" should include "${value.includes}", got "${attrValue}"`);
        }
        break;
        
      case 'no-errors':
        // Check browser console for errors (would need log file access)
        // For now, this is a placeholder
        break;
        
      default:
        throw new Error(`Unknown assertion type: ${type}`);
    }
    
    // Log success after assertion passes
    if (verbose) {
      console.log(`    ${c.dim}✓ assert ${type}: ${JSON.stringify(value)}${c.reset}`);
    }
  }
}

function printSummary(results) {
  console.log(`\n${c.cyan}═══════════════════════════════════════${c.reset}`);
  console.log(`${c.cyan}Test Results${c.reset}`);
  console.log(`${c.cyan}═══════════════════════════════════════${c.reset}`);
  
  for (const suite of results.suites) {
    const icon = suite.failed > 0 ? c.red + '✗' : c.green + '✓';
    console.log(`\n${icon}${c.reset} ${suite.name}`);
    console.log(`  ${c.dim}${suite.passed} passed, ${suite.failed} failed, ${suite.skipped} skipped (${suite.duration}ms)${c.reset}`);
  }
  
  console.log(`\n${c.cyan}───────────────────────────────────────${c.reset}`);
  
  const icon = results.failed > 0 ? c.red + '✗' : c.green + '✓';
  console.log(`${icon} Total: ${results.passed} passed, ${results.failed} failed, ${results.skipped} skipped${c.reset}`);
  console.log(`${c.dim}Duration: ${results.duration}ms${c.reset}`);
  
  if (results.failed > 0) {
    console.log(`\n${c.red}Some tests failed!${c.reset}`);
  } else {
    console.log(`\n${c.green}All tests passed!${c.reset}`);
  }
}

function generateJUnitXml(results) {
  const lines = ['<?xml version="1.0" encoding="UTF-8"?>'];
  lines.push(`<testsuites tests="${results.totalTests}" failures="${results.failed}" time="${results.duration / 1000}">`);
  
  for (const suite of results.suites) {
    lines.push(`  <testsuite name="${escapeXml(suite.name)}" tests="${suite.tests.length}" failures="${suite.failed}" time="${suite.duration / 1000}">`);
    
    for (const test of suite.tests) {
      if (test.status === 'passed') {
        lines.push(`    <testcase name="${escapeXml(test.name)}" time="${test.duration / 1000}"/>`);
      } else if (test.status === 'failed') {
        lines.push(`    <testcase name="${escapeXml(test.name)}" time="${test.duration / 1000}">`);
        lines.push(`      <failure message="${escapeXml(test.error || 'Unknown error')}">${escapeXml(test.error || '')}</failure>`);
        lines.push(`    </testcase>`);
      } else {
        lines.push(`    <testcase name="${escapeXml(test.name)}" time="0">`);
        lines.push(`      <skipped/>`);
        lines.push(`    </testcase>`);
      }
    }
    
    lines.push(`  </testsuite>`);
  }
  
  lines.push('</testsuites>');
  return lines.join('\n');
}

function escapeXml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// Help
function showHelp() {
  console.log(`
${c.cyan}browser-ctl${c.reset} - Control browser via Playwright + CDP

${c.yellow}USAGE${c.reset}
  browser-ctl <command> [options]

${c.yellow}COMMANDS${c.reset}
  ${c.green}screenshot${c.reset} [selector] [--full] [-o file] [--max N] [--no-resize]
      Take screenshot of page or element
      Auto-resizes to 1500px max (AI-friendly). Use --no-resize to disable.
      
  ${c.green}logs${c.reset} [--level LEVEL] [--json] [-n LINES] [--follow] [--clear]
      Show console logs from log file (collected by browser-open daemon)
      -n, --lines N    Show last N lines (default: 50)
      -a, --all        Show all logs
      -f, --follow     Tail the log file (like tail -f)
      -c, --clear      Clear the log file
      Levels: debug, log, info, warn, error
      
  ${c.green}click${c.reset} <selector>
      Click an element
      
  ${c.green}type${c.reset} <selector> <text>
      Type text into an input
      
  ${c.green}goto${c.reset} <url>
      Navigate to URL (supports relative paths like /accounts)
      
  ${c.green}eval${c.reset} <javascript>
      Execute JavaScript and print result
      
  ${c.green}html${c.reset} [selector]
      Get HTML content of page or element
      
  ${c.green}snapshot${c.reset}
      Get accessibility tree (like Cursor's browser_snapshot)
      
  ${c.green}url${c.reset}
      Print current URL
      
  ${c.green}title${c.reset}
      Print page title
      
  ${c.green}wait${c.reset} <selector|url:pattern|text:content> [timeout]
      Wait for element, URL, or text
      
  ${c.green}reload${c.reset}
      Reload current page
      
  ${c.green}tabs${c.reset}
      List all open tabs
      
  ${c.green}tab${c.reset} <index>
      Switch to tab by index
      
  ${c.green}test${c.reset} <file.yaml|directory> [options]
      Run browser tests from YAML/JSON specs
      --verbose, -v     Show detailed step output
      --json            Output results as JSON
      --junit=FILE      Write JUnit XML report
      --bail            Stop on first failure
      --filter=PATTERN  Only run tests matching pattern

${c.yellow}EXAMPLES${c.reset}
  browser-ctl screenshot --full
  browser-ctl logs                        # Last 50 log entries
  browser-ctl logs --level error          # Only errors
  browser-ctl logs -n 100 --json          # Last 100 as JSON
  browser-ctl logs --follow               # Tail logs (like tail -f)
  browser-ctl click "button[type=submit]"
  browser-ctl type "#search" "hello world"
  browser-ctl goto /accounts
  browser-ctl eval "document.querySelectorAll('button').length"
  browser-ctl wait "text:Loading" 10000
  browser-ctl html ".sidebar"
  browser-ctl test tests/browser/              # Run all tests in directory
  browser-ctl test tests/browser/auth.yaml     # Run single test file
  browser-ctl test tests/ --junit=results.xml  # Generate JUnit report
  browser-ctl test tests/ --filter="login"     # Only run tests matching "login"

${c.yellow}ENVIRONMENT${c.reset}
  CDP_PORT         Chrome debugging port (default: 9222)
  CDP_HOST         Chrome host (default: localhost)
  SCREENSHOT_DIR   Screenshot output directory (default: /tmp/browser-ctl)

${c.yellow}SETUP${c.reset}
  First, launch Chrome with debugging enabled:
    ${c.cyan}browser-open${c.reset}
  
  Then use browser-ctl commands to interact with it.
`);
}

// Main
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  const cmdArgs = args.slice(1);
  
  if (!command || command === '--help' || command === '-h') {
    showHelp();
    process.exit(0);
  }
  
  switch (command) {
    case 'screenshot':
    case 'ss':
      await cmdScreenshot(cmdArgs);
      break;
    case 'logs':
    case 'log':
      await cmdLogs(cmdArgs);
      break;
    case 'click':
      await cmdClick(cmdArgs);
      break;
    case 'type':
      await cmdType(cmdArgs);
      break;
    case 'goto':
    case 'go':
      await cmdGoto(cmdArgs);
      break;
    case 'eval':
    case 'js':
      await cmdEval(cmdArgs);
      break;
    case 'html':
      await cmdHtml(cmdArgs);
      break;
    case 'snapshot':
    case 'snap':
      await cmdSnapshot(cmdArgs);
      break;
    case 'url':
      await cmdUrl(cmdArgs);
      break;
    case 'title':
      await cmdTitle(cmdArgs);
      break;
    case 'wait':
      await cmdWait(cmdArgs);
      break;
    case 'reload':
      await cmdReload(cmdArgs);
      break;
    case 'tabs':
      await cmdTabs(cmdArgs);
      break;
    case 'tab':
      await cmdTab(cmdArgs);
      break;
    case 'test':
      await cmdTest(cmdArgs);
      break;
    default:
      console.error(`${c.red}Unknown command: ${command}${c.reset}`);
      console.error(`Run 'browser-ctl --help' for usage`);
      process.exit(1);
  }
}

main().catch(err => {
  console.error(`${c.red}Error: ${err.message}${c.reset}`);
  process.exit(1);
});
