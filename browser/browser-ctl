#!/usr/bin/env node
/**
 * browser-ctl - Control browser via Playwright + CDP
 * 
 * Connects to Chrome with remote debugging and provides full control:
 * - Screenshots
 * - Console logs
 * - Click, type, navigate
 * - JavaScript evaluation
 * - Accessibility snapshots
 * 
 * Usage:
 *   browser-ctl screenshot                    # Screenshot current page
 *   browser-ctl logs                          # Stream console logs
 *   browser-ctl click "button.submit"         # Click element
 *   browser-ctl goto "/accounts"              # Navigate
 *   browser-ctl eval "document.title"         # Run JS
 */

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

// Config
const CDP_PORT = process.env.CDP_PORT || 9222;
const CDP_HOST = process.env.CDP_HOST || 'localhost';
const SCREENSHOT_DIR = process.env.SCREENSHOT_DIR || '/tmp/browser-ctl';

// ANSI colors
const c = {
  reset: '\x1b[0m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
};

// Ensure screenshot directory exists
if (!fs.existsSync(SCREENSHOT_DIR)) {
  fs.mkdirSync(SCREENSHOT_DIR, { recursive: true });
}

// ARIA Snapshot script - injected into browser for YAML snapshots with refs
// Ported from dev-browser (github.com/SawyerHood/dev-browser)
const SNAPSHOT_SCRIPT = `
(function() {
  if (window.__devBrowser_getAISnapshot) return;

  // === domUtils ===
  let cacheStyle;
  let cachesCounter = 0;

  function beginDOMCaches() {
    ++cachesCounter;
    cacheStyle = cacheStyle || new Map();
  }

  function endDOMCaches() {
    if (!--cachesCounter) {
      cacheStyle = undefined;
    }
  }

  function getElementComputedStyle(element, pseudo) {
    const cache = cacheStyle;
    const cacheKey = pseudo ? undefined : element;
    if (cache && cacheKey && cache.has(cacheKey)) return cache.get(cacheKey);
    const style = element.ownerDocument && element.ownerDocument.defaultView
      ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo)
      : undefined;
    if (cache && cacheKey) cache.set(cacheKey, style);
    return style;
  }

  function parentElementOrShadowHost(element) {
    if (element.parentElement) return element.parentElement;
    if (!element.parentNode) return;
    if (element.parentNode.nodeType === 11 && element.parentNode.host)
      return element.parentNode.host;
  }

  function enclosingShadowRootOrDocument(element) {
    let node = element;
    while (node.parentNode) node = node.parentNode;
    if (node.nodeType === 11 || node.nodeType === 9)
      return node;
  }

  function closestCrossShadow(element, css, scope) {
    while (element) {
      const closest = element.closest(css);
      if (scope && closest !== scope && closest?.contains(scope)) return;
      if (closest) return closest;
      element = enclosingShadowHost(element);
    }
  }

  function enclosingShadowHost(element) {
    while (element.parentElement) element = element.parentElement;
    return parentElementOrShadowHost(element);
  }

  function isElementStyleVisibilityVisible(element, style) {
    style = style || getElementComputedStyle(element);
    if (!style) return true;
    if (style.visibility !== "visible") return false;
    const detailsOrSummary = element.closest("details,summary");
    if (detailsOrSummary !== element && detailsOrSummary?.nodeName === "DETAILS" && !detailsOrSummary.open)
      return false;
    return true;
  }

  function computeBox(element) {
    const style = getElementComputedStyle(element);
    if (!style) return { visible: true, inline: false };
    const cursor = style.cursor;
    if (style.display === "contents") {
      for (let child = element.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 1 && isElementVisible(child))
          return { visible: true, inline: false, cursor };
        if (child.nodeType === 3 && isVisibleTextNode(child))
          return { visible: true, inline: true, cursor };
      }
      return { visible: false, inline: false, cursor };
    }
    if (!isElementStyleVisibilityVisible(element, style))
      return { cursor, visible: false, inline: false };
    const rect = element.getBoundingClientRect();
    return { rect, cursor, visible: rect.width > 0 && rect.height > 0, inline: style.display === "inline" };
  }

  function isElementVisible(element) {
    return computeBox(element).visible;
  }

  function isVisibleTextNode(node) {
    const range = node.ownerDocument.createRange();
    range.selectNode(node);
    const rect = range.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0;
  }

  function elementSafeTagName(element) {
    const tagName = element.tagName;
    if (typeof tagName === "string") return tagName.toUpperCase();
    if (element instanceof HTMLFormElement) return "FORM";
    return element.tagName.toUpperCase();
  }

  function normalizeWhiteSpace(text) {
    return text.split("\\u00A0").map(chunk =>
      chunk.replace(/\\r\\n/g, "\\n").replace(/[\\u200b\\u00ad]/g, "").replace(/\\s\\s*/g, " ")
    ).join("\\u00A0").trim();
  }

  // === yaml ===
  function yamlEscapeKeyIfNeeded(str) {
    if (!yamlStringNeedsQuotes(str)) return str;
    return "'" + str.replace(/'/g, "''") + "'";
  }

  function yamlEscapeValueIfNeeded(str) {
    if (!yamlStringNeedsQuotes(str)) return str;
    return '"' + str.replace(/[\\\\"\x00-\\x1f\\x7f-\\x9f]/g, c => {
      switch (c) {
        case "\\\\": return "\\\\\\\\";
        case '"': return '\\\\"';
        case "\\b": return "\\\\b";
        case "\\f": return "\\\\f";
        case "\\n": return "\\\\n";
        case "\\r": return "\\\\r";
        case "\\t": return "\\\\t";
        default:
          const code = c.charCodeAt(0);
          return "\\\\x" + code.toString(16).padStart(2, "0");
      }
    }) + '"';
  }

  function yamlStringNeedsQuotes(str) {
    if (str.length === 0) return true;
    if (/^\\s|\\s$/.test(str)) return true;
    if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str)) return true;
    if (/^-/.test(str)) return true;
    if (/[\\n:](\\s|$)/.test(str)) return true;
    if (/\\s#/.test(str)) return true;
    if (/[\\n\\r]/.test(str)) return true;
    if (/^[&*\\],?!>|@"'#%]/.test(str)) return true;
    if (/[{}]/.test(str)) return true;
    if (/^\\[/.test(str)) return true;
    if (!isNaN(Number(str)) || ["y","n","yes","no","true","false","on","off","null"].includes(str.toLowerCase())) return true;
    return false;
  }

  // === roleUtils ===
  const validRoles = ["alert","alertdialog","application","article","banner","blockquote","button","caption","cell","checkbox","code","columnheader","combobox","complementary","contentinfo","definition","deletion","dialog","directory","document","emphasis","feed","figure","form","generic","grid","gridcell","group","heading","img","insertion","link","list","listbox","listitem","log","main","mark","marquee","math","meter","menu","menubar","menuitem","menuitemcheckbox","menuitemradio","navigation","none","note","option","paragraph","presentation","progressbar","radio","radiogroup","region","row","rowgroup","rowheader","scrollbar","search","searchbox","separator","slider","spinbutton","status","strong","subscript","superscript","switch","tab","table","tablist","tabpanel","term","textbox","time","timer","toolbar","tooltip","tree","treegrid","treeitem"];

  let cacheAccessibleName;
  let cacheIsHidden;
  let cachePointerEvents;
  let ariaCachesCounter = 0;

  function beginAriaCaches() {
    beginDOMCaches();
    ++ariaCachesCounter;
    cacheAccessibleName = cacheAccessibleName || new Map();
    cacheIsHidden = cacheIsHidden || new Map();
    cachePointerEvents = cachePointerEvents || new Map();
  }

  function endAriaCaches() {
    if (!--ariaCachesCounter) {
      cacheAccessibleName = undefined;
      cacheIsHidden = undefined;
      cachePointerEvents = undefined;
    }
    endDOMCaches();
  }

  function hasExplicitAccessibleName(e) {
    return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");
  }

  const kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";

  const kGlobalAriaAttributes = [
    ["aria-atomic", undefined],["aria-busy", undefined],["aria-controls", undefined],["aria-current", undefined],
    ["aria-describedby", undefined],["aria-details", undefined],["aria-dropeffect", undefined],["aria-flowto", undefined],
    ["aria-grabbed", undefined],["aria-hidden", undefined],["aria-keyshortcuts", undefined],
    ["aria-label", ["caption","code","deletion","emphasis","generic","insertion","paragraph","presentation","strong","subscript","superscript"]],
    ["aria-labelledby", ["caption","code","deletion","emphasis","generic","insertion","paragraph","presentation","strong","subscript","superscript"]],
    ["aria-live", undefined],["aria-owns", undefined],["aria-relevant", undefined],["aria-roledescription", ["generic"]]
  ];

  function hasGlobalAriaAttribute(element, forRole) {
    return kGlobalAriaAttributes.some(([attr, prohibited]) => !prohibited?.includes(forRole || "") && element.hasAttribute(attr));
  }

  function hasTabIndex(element) {
    return !Number.isNaN(Number(String(element.getAttribute("tabindex"))));
  }

  function isFocusable(element) {
    return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));
  }

  function isNativelyFocusable(element) {
    const tagName = elementSafeTagName(element);
    if (["BUTTON","DETAILS","SELECT","TEXTAREA"].includes(tagName)) return true;
    if (tagName === "A" || tagName === "AREA") return element.hasAttribute("href");
    if (tagName === "INPUT") return !element.hidden;
    return false;
  }

  function isNativelyDisabled(element) {
    const isNativeFormControl = ["BUTTON","INPUT","SELECT","TEXTAREA","OPTION","OPTGROUP"].includes(elementSafeTagName(element));
    return isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledFieldSet(element));
  }

  function belongsToDisabledFieldSet(element) {
    const fieldSetElement = element?.closest("FIELDSET[DISABLED]");
    if (!fieldSetElement) return false;
    const legendElement = fieldSetElement.querySelector(":scope > LEGEND");
    return !legendElement || !legendElement.contains(element);
  }

  const inputTypeToRole = {button:"button",checkbox:"checkbox",image:"button",number:"spinbutton",radio:"radio",range:"slider",reset:"button",submit:"button"};

  function getIdRefs(element, ref) {
    if (!ref) return [];
    const root = enclosingShadowRootOrDocument(element);
    if (!root) return [];
    try {
      const ids = ref.split(" ").filter(id => !!id);
      const result = [];
      for (const id of ids) {
        const firstElement = root.querySelector("#" + CSS.escape(id));
        if (firstElement && !result.includes(firstElement)) result.push(firstElement);
      }
      return result;
    } catch { return []; }
  }

  const kImplicitRoleByTagName = {
    A: e => e.hasAttribute("href") ? "link" : null,
    AREA: e => e.hasAttribute("href") ? "link" : null,
    ARTICLE: () => "article", ASIDE: () => "complementary", BLOCKQUOTE: () => "blockquote", BUTTON: () => "button",
    CAPTION: () => "caption", CODE: () => "code", DATALIST: () => "listbox", DD: () => "definition",
    DEL: () => "deletion", DETAILS: () => "group", DFN: () => "term", DIALOG: () => "dialog", DT: () => "term",
    EM: () => "emphasis", FIELDSET: () => "group", FIGURE: () => "figure",
    FOOTER: e => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",
    FORM: e => hasExplicitAccessibleName(e) ? "form" : null,
    H1: () => "heading", H2: () => "heading", H3: () => "heading", H4: () => "heading", H5: () => "heading", H6: () => "heading",
    HEADER: e => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",
    HR: () => "separator", HTML: () => "document",
    IMG: e => e.getAttribute("alt") === "" && !e.getAttribute("title") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? "presentation" : "img",
    INPUT: e => {
      const type = e.type.toLowerCase();
      if (type === "search") return e.hasAttribute("list") ? "combobox" : "searchbox";
      if (["email","tel","text","url",""].includes(type)) {
        const list = getIdRefs(e, e.getAttribute("list"))[0];
        return list && elementSafeTagName(list) === "DATALIST" ? "combobox" : "textbox";
      }
      if (type === "hidden") return null;
      if (type === "file") return "button";
      return inputTypeToRole[type] || "textbox";
    },
    INS: () => "insertion", LI: () => "listitem", MAIN: () => "main", MARK: () => "mark", MATH: () => "math",
    MENU: () => "list", METER: () => "meter", NAV: () => "navigation", OL: () => "list", OPTGROUP: () => "group",
    OPTION: () => "option", OUTPUT: () => "status", P: () => "paragraph", PROGRESS: () => "progressbar",
    SEARCH: () => "search", SECTION: e => hasExplicitAccessibleName(e) ? "region" : null,
    SELECT: e => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",
    STRONG: () => "strong", SUB: () => "subscript", SUP: () => "superscript", SVG: () => "img",
    TABLE: () => "table", TBODY: () => "rowgroup",
    TD: e => { const table = closestCrossShadow(e, "table"); const role = table ? getExplicitAriaRole(table) : ""; return role === "grid" || role === "treegrid" ? "gridcell" : "cell"; },
    TEXTAREA: () => "textbox", TFOOT: () => "rowgroup",
    TH: e => { const scope = e.getAttribute("scope"); if (scope === "col" || scope === "colgroup") return "columnheader"; if (scope === "row" || scope === "rowgroup") return "rowheader"; return "columnheader"; },
    THEAD: () => "rowgroup", TIME: () => "time", TR: () => "row", UL: () => "list"
  };

  function getExplicitAriaRole(element) {
    const roles = (element.getAttribute("role") || "").split(" ").map(role => role.trim());
    return roles.find(role => validRoles.includes(role)) || null;
  }

  function getImplicitAriaRole(element) {
    const fn = kImplicitRoleByTagName[elementSafeTagName(element)];
    return fn ? fn(element) : null;
  }

  function hasPresentationConflictResolution(element, role) {
    return hasGlobalAriaAttribute(element, role) || isFocusable(element);
  }

  function getAriaRole(element) {
    const explicitRole = getExplicitAriaRole(element);
    if (!explicitRole) return getImplicitAriaRole(element);
    if (explicitRole === "none" || explicitRole === "presentation") {
      const implicitRole = getImplicitAriaRole(element);
      if (hasPresentationConflictResolution(element, implicitRole)) return implicitRole;
    }
    return explicitRole;
  }

  function getAriaBoolean(attr) {
    return attr === null ? undefined : attr.toLowerCase() === "true";
  }

  function isElementIgnoredForAria(element) {
    return ["STYLE","SCRIPT","NOSCRIPT","TEMPLATE"].includes(elementSafeTagName(element));
  }

  function isElementHiddenForAria(element) {
    if (isElementIgnoredForAria(element)) return true;
    const style = getElementComputedStyle(element);
    const isSlot = element.nodeName === "SLOT";
    if (style?.display === "contents" && !isSlot) {
      for (let child = element.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 1 && !isElementHiddenForAria(child)) return false;
        if (child.nodeType === 3 && isVisibleTextNode(child)) return false;
      }
      return true;
    }
    const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");
    if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style)) return true;
    return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);
  }

  function belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {
    let hidden = cacheIsHidden?.get(element);
    if (hidden === undefined) {
      hidden = false;
      if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot) hidden = true;
      if (!hidden) {
        const style = getElementComputedStyle(element);
        hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;
      }
      if (!hidden) {
        const parent = parentElementOrShadowHost(element);
        if (parent) hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);
      }
      cacheIsHidden?.set(element, hidden);
    }
    return hidden;
  }

  function getAriaLabelledByElements(element) {
    const ref = element.getAttribute("aria-labelledby");
    if (ref === null) return null;
    const refs = getIdRefs(element, ref);
    return refs.length ? refs : null;
  }

  function getElementAccessibleName(element, includeHidden) {
    let accessibleName = cacheAccessibleName?.get(element);
    if (accessibleName === undefined) {
      accessibleName = "";
      const elementProhibitsNaming = ["caption","code","definition","deletion","emphasis","generic","insertion","mark","paragraph","presentation","strong","subscript","suggestion","superscript","term","time"].includes(getAriaRole(element) || "");
      if (!elementProhibitsNaming) {
        accessibleName = normalizeWhiteSpace(getTextAlternativeInternal(element, { includeHidden, visitedElements: new Set(), embeddedInTargetElement: "self" }));
      }
      cacheAccessibleName?.set(element, accessibleName);
    }
    return accessibleName;
  }

  function getTextAlternativeInternal(element, options) {
    if (options.visitedElements.has(element)) return "";
    const childOptions = { ...options, embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement };

    if (!options.includeHidden) {
      const isEmbeddedInHiddenReferenceTraversal = !!options.embeddedInLabelledBy?.hidden || !!options.embeddedInLabel?.hidden;
      if (isElementIgnoredForAria(element) || (!isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element))) {
        options.visitedElements.add(element);
        return "";
      }
    }

    const labelledBy = getAriaLabelledByElements(element);
    if (!options.embeddedInLabelledBy) {
      const accessibleName = (labelledBy || []).map(ref => getTextAlternativeInternal(ref, { ...options, embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) }, embeddedInTargetElement: undefined, embeddedInLabel: undefined })).join(" ");
      if (accessibleName) return accessibleName;
    }

    const role = getAriaRole(element) || "";
    const tagName = elementSafeTagName(element);

    const ariaLabel = element.getAttribute("aria-label") || "";
    if (ariaLabel.trim()) { options.visitedElements.add(element); return ariaLabel; }

    if (!["presentation","none"].includes(role)) {
      if (tagName === "INPUT" && ["button","submit","reset"].includes(element.type)) {
        options.visitedElements.add(element);
        const value = element.value || "";
        if (value.trim()) return value;
        if (element.type === "submit") return "Submit";
        if (element.type === "reset") return "Reset";
        return element.getAttribute("title") || "";
      }
      if (tagName === "INPUT" && element.type === "image") {
        options.visitedElements.add(element);
        const alt = element.getAttribute("alt") || "";
        if (alt.trim()) return alt;
        const title = element.getAttribute("title") || "";
        if (title.trim()) return title;
        return "Submit";
      }
      if (tagName === "IMG") {
        options.visitedElements.add(element);
        const alt = element.getAttribute("alt") || "";
        if (alt.trim()) return alt;
        return element.getAttribute("title") || "";
      }
      if (!labelledBy && ["BUTTON","INPUT","TEXTAREA","SELECT"].includes(tagName)) {
        const labels = element.labels;
        if (labels?.length) {
          options.visitedElements.add(element);
          return [...labels].map(label => getTextAlternativeInternal(label, { ...options, embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) }, embeddedInLabelledBy: undefined, embeddedInTargetElement: undefined })).filter(name => !!name).join(" ");
        }
      }
    }

    const allowsNameFromContent = ["button","cell","checkbox","columnheader","gridcell","heading","link","menuitem","menuitemcheckbox","menuitemradio","option","radio","row","rowheader","switch","tab","tooltip","treeitem"].includes(role);
    if (allowsNameFromContent || !!options.embeddedInLabelledBy || !!options.embeddedInLabel) {
      options.visitedElements.add(element);
      const accessibleName = innerAccumulatedElementText(element, childOptions);
      const maybeTrimmedAccessibleName = options.embeddedInTargetElement === "self" ? accessibleName.trim() : accessibleName;
      if (maybeTrimmedAccessibleName) return accessibleName;
    }

    if (!["presentation","none"].includes(role) || tagName === "IFRAME") {
      options.visitedElements.add(element);
      const title = element.getAttribute("title") || "";
      if (title.trim()) return title;
    }

    options.visitedElements.add(element);
    return "";
  }

  function innerAccumulatedElementText(element, options) {
    const tokens = [];
    const visit = (node, skipSlotted) => {
      if (skipSlotted && node.assignedSlot) return;
      if (node.nodeType === 1) {
        const display = getElementComputedStyle(node)?.display || "inline";
        let token = getTextAlternativeInternal(node, options);
        if (display !== "inline" || node.nodeName === "BR") token = " " + token + " ";
        tokens.push(token);
      } else if (node.nodeType === 3) {
        tokens.push(node.textContent || "");
      }
    };
    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];
    if (assignedNodes.length) {
      for (const child of assignedNodes) visit(child, false);
    } else {
      for (let child = element.firstChild; child; child = child.nextSibling) visit(child, true);
      if (element.shadowRoot) {
        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling) visit(child, true);
      }
    }
    return tokens.join("");
  }

  const kAriaCheckedRoles = ["checkbox","menuitemcheckbox","option","radio","switch","menuitemradio","treeitem"];
  function getAriaChecked(element) {
    const tagName = elementSafeTagName(element);
    if (tagName === "INPUT" && element.indeterminate) return "mixed";
    if (tagName === "INPUT" && ["checkbox","radio"].includes(element.type)) return element.checked;
    if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {
      const checked = element.getAttribute("aria-checked");
      if (checked === "true") return true;
      if (checked === "mixed") return "mixed";
      return false;
    }
    return false;
  }

  const kAriaDisabledRoles = ["application","button","composite","gridcell","group","input","link","menuitem","scrollbar","separator","tab","checkbox","columnheader","combobox","grid","listbox","menu","menubar","menuitemcheckbox","menuitemradio","option","radio","radiogroup","row","rowheader","searchbox","select","slider","spinbutton","switch","tablist","textbox","toolbar","tree","treegrid","treeitem"];
  function getAriaDisabled(element) {
    return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);
  }
  function hasExplicitAriaDisabled(element, isAncestor) {
    if (!element) return false;
    if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || "")) {
      const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();
      if (attribute === "true") return true;
      if (attribute === "false") return false;
      return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);
    }
    return false;
  }

  const kAriaExpandedRoles = ["application","button","checkbox","combobox","gridcell","link","listbox","menuitem","row","rowheader","tab","treeitem","columnheader","menuitemcheckbox","menuitemradio","switch"];
  function getAriaExpanded(element) {
    if (elementSafeTagName(element) === "DETAILS") return element.open;
    if (kAriaExpandedRoles.includes(getAriaRole(element) || "")) {
      const expanded = element.getAttribute("aria-expanded");
      if (expanded === null) return undefined;
      if (expanded === "true") return true;
      return false;
    }
    return undefined;
  }

  const kAriaLevelRoles = ["heading","listitem","row","treeitem"];
  function getAriaLevel(element) {
    const native = {H1:1,H2:2,H3:3,H4:4,H5:5,H6:6}[elementSafeTagName(element)];
    if (native) return native;
    if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {
      const attr = element.getAttribute("aria-level");
      const value = attr === null ? Number.NaN : Number(attr);
      if (Number.isInteger(value) && value >= 1) return value;
    }
    return 0;
  }

  const kAriaPressedRoles = ["button"];
  function getAriaPressed(element) {
    if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {
      const pressed = element.getAttribute("aria-pressed");
      if (pressed === "true") return true;
      if (pressed === "mixed") return "mixed";
    }
    return false;
  }

  const kAriaSelectedRoles = ["gridcell","option","row","tab","rowheader","columnheader","treeitem"];
  function getAriaSelected(element) {
    if (elementSafeTagName(element) === "OPTION") return element.selected;
    if (kAriaSelectedRoles.includes(getAriaRole(element) || "")) return getAriaBoolean(element.getAttribute("aria-selected")) === true;
    return false;
  }

  function receivesPointerEvents(element) {
    const cache = cachePointerEvents;
    let e = element;
    let result;
    const parents = [];
    for (; e; e = parentElementOrShadowHost(e)) {
      const cached = cache?.get(e);
      if (cached !== undefined) { result = cached; break; }
      parents.push(e);
      const style = getElementComputedStyle(e);
      if (!style) { result = true; break; }
      const value = style.pointerEvents;
      if (value) { result = value !== "none"; break; }
    }
    if (result === undefined) result = true;
    for (const parent of parents) cache?.set(parent, result);
    return result;
  }

  function getCSSContent(element, pseudo) {
    const style = getElementComputedStyle(element, pseudo);
    if (!style) return undefined;
    const contentValue = style.content;
    if (!contentValue || contentValue === "none" || contentValue === "normal") return undefined;
    if (style.display === "none" || style.visibility === "hidden") return undefined;
    const match = contentValue.match(/^"(.*)"$/);
    if (match) {
      const content = match[1].replace(/\\\\"/g, '"');
      if (pseudo) {
        const display = style.display || "inline";
        if (display !== "inline") return " " + content + " ";
      }
      return content;
    }
    return undefined;
  }

  // === ariaSnapshot ===
  let lastRef = 0;

  function generateAriaTree(rootElement) {
    const options = { visibility: "ariaOrVisible", refs: "interactable", refPrefix: "", includeGenericRole: true, renderActive: true, renderCursorPointer: true };
    const visited = new Set();
    const snapshot = {
      root: { role: "fragment", name: "", children: [], element: rootElement, props: {}, box: computeBox(rootElement), receivesPointerEvents: true },
      elements: new Map(),
      refs: new Map(),
      iframeRefs: []
    };

    const visit = (ariaNode, node, parentElementVisible) => {
      if (visited.has(node)) return;
      visited.add(node);
      if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {
        if (!parentElementVisible) return;
        const text = node.nodeValue;
        if (ariaNode.role !== "textbox" && text) ariaNode.children.push(node.nodeValue || "");
        return;
      }
      if (node.nodeType !== Node.ELEMENT_NODE) return;
      const element = node;
      const isElementVisibleForAria = !isElementHiddenForAria(element);
      let visible = isElementVisibleForAria;
      if (options.visibility === "ariaOrVisible") visible = isElementVisibleForAria || isElementVisible(element);
      if (options.visibility === "ariaAndVisible") visible = isElementVisibleForAria && isElementVisible(element);
      if (options.visibility === "aria" && !visible) return;
      const ariaChildren = [];
      if (element.hasAttribute("aria-owns")) {
        const ids = element.getAttribute("aria-owns").split(/\\s+/);
        for (const id of ids) {
          const ownedElement = rootElement.ownerDocument.getElementById(id);
          if (ownedElement) ariaChildren.push(ownedElement);
        }
      }
      const childAriaNode = visible ? toAriaNode(element, options) : null;
      if (childAriaNode) {
        if (childAriaNode.ref) {
          snapshot.elements.set(childAriaNode.ref, element);
          snapshot.refs.set(element, childAriaNode.ref);
          if (childAriaNode.role === "iframe") snapshot.iframeRefs.push(childAriaNode.ref);
        }
        ariaNode.children.push(childAriaNode);
      }
      processElement(childAriaNode || ariaNode, element, ariaChildren, visible);
    };

    function processElement(ariaNode, element, ariaChildren, parentElementVisible) {
      const display = getElementComputedStyle(element)?.display || "inline";
      const treatAsBlock = display !== "inline" || element.nodeName === "BR" ? " " : "";
      if (treatAsBlock) ariaNode.children.push(treatAsBlock);
      ariaNode.children.push(getCSSContent(element, "::before") || "");
      const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];
      if (assignedNodes.length) {
        for (const child of assignedNodes) visit(ariaNode, child, parentElementVisible);
      } else {
        for (let child = element.firstChild; child; child = child.nextSibling) {
          if (!child.assignedSlot) visit(ariaNode, child, parentElementVisible);
        }
        if (element.shadowRoot) {
          for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling) visit(ariaNode, child, parentElementVisible);
        }
      }
      for (const child of ariaChildren) visit(ariaNode, child, parentElementVisible);
      ariaNode.children.push(getCSSContent(element, "::after") || "");
      if (treatAsBlock) ariaNode.children.push(treatAsBlock);
      if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0]) ariaNode.children = [];
      if (ariaNode.role === "link" && element.hasAttribute("href")) ariaNode.props["url"] = element.getAttribute("href");
      if (ariaNode.role === "textbox" && element.hasAttribute("placeholder") && element.getAttribute("placeholder") !== ariaNode.name) ariaNode.props["placeholder"] = element.getAttribute("placeholder");
    }

    beginAriaCaches();
    try { visit(snapshot.root, rootElement, true); }
    finally { endAriaCaches(); }
    normalizeStringChildren(snapshot.root);
    normalizeGenericRoles(snapshot.root);
    return snapshot;
  }

  function computeAriaRef(ariaNode, options) {
    if (options.refs === "none") return;
    if (options.refs === "interactable" && (!ariaNode.box.visible || !ariaNode.receivesPointerEvents)) return;
    let ariaRef = ariaNode.element._ariaRef;
    if (!ariaRef || ariaRef.role !== ariaNode.role || ariaRef.name !== ariaNode.name) {
      ariaRef = { role: ariaNode.role, name: ariaNode.name, ref: (options.refPrefix || "") + "e" + (++lastRef) };
      ariaNode.element._ariaRef = ariaRef;
    }
    ariaNode.ref = ariaRef.ref;
  }

  function toAriaNode(element, options) {
    const active = element.ownerDocument.activeElement === element;
    if (element.nodeName === "IFRAME") {
      const ariaNode = { role: "iframe", name: "", children: [], props: {}, element, box: computeBox(element), receivesPointerEvents: true, active };
      computeAriaRef(ariaNode, options);
      return ariaNode;
    }
    const defaultRole = options.includeGenericRole ? "generic" : null;
    const role = getAriaRole(element) || defaultRole;
    if (!role || role === "presentation" || role === "none") return null;
    const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || "");
    const receivesPointerEventsValue = receivesPointerEvents(element);
    const box = computeBox(element);
    if (role === "generic" && box.inline && element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE) return null;
    const result = { role, name, children: [], props: {}, element, box, receivesPointerEvents: receivesPointerEventsValue, active };
    computeAriaRef(result, options);
    if (kAriaCheckedRoles.includes(role)) result.checked = getAriaChecked(element);
    if (kAriaDisabledRoles.includes(role)) result.disabled = getAriaDisabled(element);
    if (kAriaExpandedRoles.includes(role)) result.expanded = getAriaExpanded(element);
    if (kAriaLevelRoles.includes(role)) result.level = getAriaLevel(element);
    if (kAriaPressedRoles.includes(role)) result.pressed = getAriaPressed(element);
    if (kAriaSelectedRoles.includes(role)) result.selected = getAriaSelected(element);
    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
      if (element.type !== "checkbox" && element.type !== "radio" && element.type !== "file") result.children = [element.value];
    }
    return result;
  }

  function normalizeGenericRoles(node) {
    const normalizeChildren = (node) => {
      const result = [];
      for (const child of node.children || []) {
        if (typeof child === "string") { result.push(child); continue; }
        const normalized = normalizeChildren(child);
        result.push(...normalized);
      }
      const removeSelf = node.role === "generic" && !node.name && result.length <= 1 && result.every(c => typeof c !== "string" && !!c.ref);
      if (removeSelf) return result;
      node.children = result;
      return [node];
    };
    normalizeChildren(node);
  }

  function normalizeStringChildren(rootA11yNode) {
    const flushChildren = (buffer, normalizedChildren) => {
      if (!buffer.length) return;
      const text = normalizeWhiteSpace(buffer.join(""));
      if (text) normalizedChildren.push(text);
      buffer.length = 0;
    };
    const visit = (ariaNode) => {
      const normalizedChildren = [];
      const buffer = [];
      for (const child of ariaNode.children || []) {
        if (typeof child === "string") { buffer.push(child); }
        else { flushChildren(buffer, normalizedChildren); visit(child); normalizedChildren.push(child); }
      }
      flushChildren(buffer, normalizedChildren);
      ariaNode.children = normalizedChildren.length ? normalizedChildren : [];
      if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name) ariaNode.children = [];
    };
    visit(rootA11yNode);
  }

  function hasPointerCursor(ariaNode) { return ariaNode.box.cursor === "pointer"; }

  function renderAriaTree(ariaSnapshot) {
    const options = { visibility: "ariaOrVisible", refs: "interactable", refPrefix: "", includeGenericRole: true, renderActive: true, renderCursorPointer: true };
    const lines = [];
    let nodesToRender = ariaSnapshot.root.role === "fragment" ? ariaSnapshot.root.children : [ariaSnapshot.root];

    const visitText = (text, indent) => {
      const escaped = yamlEscapeValueIfNeeded(text);
      if (escaped) lines.push(indent + "- text: " + escaped);
    };

    const createKey = (ariaNode, renderCursorPointer) => {
      let key = ariaNode.role;
      if (ariaNode.name && ariaNode.name.length <= 900) {
        const name = ariaNode.name;
        if (name) {
          const stringifiedName = name.startsWith("/") && name.endsWith("/") ? name : JSON.stringify(name);
          key += " " + stringifiedName;
        }
      }
      if (ariaNode.checked === "mixed") key += " [checked=mixed]";
      if (ariaNode.checked === true) key += " [checked]";
      if (ariaNode.disabled) key += " [disabled]";
      if (ariaNode.expanded) key += " [expanded]";
      if (ariaNode.active && options.renderActive) key += " [active]";
      if (ariaNode.level) key += " [level=" + ariaNode.level + "]";
      if (ariaNode.pressed === "mixed") key += " [pressed=mixed]";
      if (ariaNode.pressed === true) key += " [pressed]";
      if (ariaNode.selected === true) key += " [selected]";
      if (ariaNode.ref) {
        key += " [ref=" + ariaNode.ref + "]";
        if (renderCursorPointer && hasPointerCursor(ariaNode)) key += " [cursor=pointer]";
      }
      return key;
    };

    const getSingleInlinedTextChild = (ariaNode) => {
      return ariaNode?.children.length === 1 && typeof ariaNode.children[0] === "string" && !Object.keys(ariaNode.props).length ? ariaNode.children[0] : undefined;
    };

    const visit = (ariaNode, indent, renderCursorPointer) => {
      const escapedKey = indent + "- " + yamlEscapeKeyIfNeeded(createKey(ariaNode, renderCursorPointer));
      const singleInlinedTextChild = getSingleInlinedTextChild(ariaNode);
      if (!ariaNode.children.length && !Object.keys(ariaNode.props).length) {
        lines.push(escapedKey);
      } else if (singleInlinedTextChild !== undefined) {
        lines.push(escapedKey + ": " + yamlEscapeValueIfNeeded(singleInlinedTextChild));
      } else {
        lines.push(escapedKey + ":");
        for (const [name, value] of Object.entries(ariaNode.props)) lines.push(indent + "  - /" + name + ": " + yamlEscapeValueIfNeeded(value));
        const childIndent = indent + "  ";
        const inCursorPointer = !!ariaNode.ref && renderCursorPointer && hasPointerCursor(ariaNode);
        for (const child of ariaNode.children) {
          if (typeof child === "string") visitText(child, childIndent);
          else visit(child, childIndent, renderCursorPointer && !inCursorPointer);
        }
      }
    };

    for (const nodeToRender of nodesToRender) {
      if (typeof nodeToRender === "string") visitText(nodeToRender, "");
      else visit(nodeToRender, "", !!options.renderCursorPointer);
    }
    return lines.join("\\n");
  }

  function getAISnapshot() {
    const snapshot = generateAriaTree(document.body);
    const refsObject = {};
    for (const [ref, element] of snapshot.elements) refsObject[ref] = element;
    window.__browserCtlRefs = refsObject;
    return renderAriaTree(snapshot);
  }

  function selectSnapshotRef(ref) {
    const refs = window.__browserCtlRefs;
    if (!refs) throw new Error("No snapshot refs found. Run 'browser-ctl snapshot' first.");
    const element = refs[ref];
    if (!element) throw new Error('Ref "' + ref + '" not found. Available refs: ' + Object.keys(refs).join(", "));
    return element;
  }

  // Expose main functions
  window.__devBrowser_getAISnapshot = getAISnapshot;
  window.__devBrowser_selectSnapshotRef = selectSnapshotRef;
})();
`;

async function connect() {
  try {
    const browser = await chromium.connectOverCDP(`http://${CDP_HOST}:${CDP_PORT}`);
    const contexts = browser.contexts();
    if (contexts.length === 0) {
      console.error(`${c.red}No browser contexts found${c.reset}`);
      process.exit(1);
    }
    const pages = contexts[0].pages();
    if (pages.length === 0) {
      console.error(`${c.red}No pages found${c.reset}`);
      process.exit(1);
    }
    return { browser, page: pages[0], contexts };
  } catch (err) {
    if (err.message.includes('ECONNREFUSED')) {
      console.error(`${c.red}Cannot connect to Chrome on ${CDP_HOST}:${CDP_PORT}${c.reset}`);
      console.error(`\nStart Chrome with: ${c.cyan}browser-open${c.reset}`);
    } else {
      console.error(`${c.red}Connection error: ${err.message}${c.reset}`);
    }
    process.exit(1);
  }
}

// Commands

async function cmdScreenshot(args) {
  const { execSync } = require('child_process');
  const { page, browser } = await connect();
  
  let selector = null;
  let fullPage = false;
  let filename = null;
  let maxDimension = 1500; // Default max dimension (under 2000px limit for AI models)
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--full' || args[i] === '-f') {
      fullPage = true;
    } else if (args[i] === '--selector' || args[i] === '-s') {
      selector = args[++i];
    } else if (args[i] === '--output' || args[i] === '-o') {
      filename = args[++i];
    } else if (args[i] === '--max' || args[i] === '-m') {
      maxDimension = parseInt(args[++i]);
    } else if (args[i] === '--no-resize') {
      maxDimension = null;
    } else if (!args[i].startsWith('-')) {
      selector = args[i];
    }
  }
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  filename = filename || path.join(SCREENSHOT_DIR, `screenshot-${timestamp}.png`);
  
  try {
    if (selector) {
      const element = await page.$(selector);
      if (!element) {
        console.error(`${c.red}Element not found: ${selector}${c.reset}`);
        await browser.close();
        process.exit(1);
      }
      await element.screenshot({ path: filename });
    } else {
      await page.screenshot({ path: filename, fullPage });
    }
    
    // Resize to max dimension if needed (keeps aspect ratio, uses macOS sips)
    if (maxDimension) {
      try {
        // Get current dimensions
        const info = execSync(`sips -g pixelWidth -g pixelHeight "${filename}" 2>/dev/null`, { encoding: 'utf8' });
        const width = parseInt(info.match(/pixelWidth:\s*(\d+)/)?.[1] || '0');
        const height = parseInt(info.match(/pixelHeight:\s*(\d+)/)?.[1] || '0');
        
        if (width > maxDimension || height > maxDimension) {
          // Resize to fit within maxDimension, maintaining aspect ratio
          execSync(`sips --resampleHeightWidthMax ${maxDimension} "${filename}" >/dev/null 2>&1`);
          console.log(`${c.dim}Resized to max ${maxDimension}px${c.reset}`);
        }
      } catch (e) {
        // sips not available or failed, continue without resize
      }
    }
    
    console.log(`${c.green}Screenshot saved:${c.reset} ${filename}`);
    console.log(`${c.dim}Page: ${page.url()}${c.reset}`);
  } finally {
    await browser.close();
  }
}

async function cmdLogs(args) {
  const LOG_FILE = process.env.BROWSER_LOG_FILE || '/tmp/browser-ctl-logs.jsonl';
  
  let level = null;
  let json = false;
  let follow = false;
  let lines = 50;  // default last N lines
  let clear = false;
  let all = false;
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--level' || args[i] === '-l') {
      level = args[++i];
    } else if (args[i] === '--json' || args[i] === '-j') {
      json = true;
    } else if (args[i] === '--follow' || args[i] === '-f') {
      follow = true;
    } else if (args[i] === '--lines' || args[i] === '-n') {
      lines = parseInt(args[++i]);
    } else if (args[i] === '--all' || args[i] === '-a') {
      all = true;
    } else if (args[i] === '--clear' || args[i] === '-c') {
      clear = true;
    }
  }
  
  // Clear log file if requested
  if (clear) {
    fs.writeFileSync(LOG_FILE, '');
    console.log(`${c.green}Logs cleared${c.reset}`);
    return;
  }
  
  // Check if log file exists
  if (!fs.existsSync(LOG_FILE)) {
    console.error(`${c.red}No log file found at ${LOG_FILE}${c.reset}`);
    console.error(`\nStart Chrome with: ${c.cyan}browser-open${c.reset}`);
    process.exit(1);
  }
  
  const levels = ['debug', 'log', 'info', 'warn', 'error'];
  const minLevel = level ? levels.indexOf(level) : 0;
  
  function shouldShow(msgLevel) {
    const idx = levels.indexOf(msgLevel);
    return idx >= minLevel;
  }
  
  function formatLevel(lvl) {
    const colors = { error: c.red, warn: c.yellow, info: c.blue, debug: c.gray, log: c.reset };
    return (colors[lvl] || c.reset) + lvl.toUpperCase().padEnd(5) + c.reset;
  }
  
  function formatEntry(entry) {
    if (json) {
      console.log(JSON.stringify(entry));
      return;
    }
    
    // Skip collector meta messages unless showing all
    if (entry.type === 'collector' && !all) return;
    
    const ts = c.dim + (entry.ts || '').split('T')[1]?.slice(0, 12) || '' + c.reset;
    const lvl = formatLevel(entry.level);
    const loc = entry.url ? ` ${c.dim}(${path.basename(entry.url)}${entry.line ? ':' + entry.line : ''})${c.reset}` : '';
    const typeTag = entry.type && entry.type !== 'collector' ? `${c.dim}[${entry.type.toUpperCase()}]${c.reset} ` : '';
    
    console.log(`${ts} ${lvl} ${typeTag}${entry.message}${loc}`);
  }
  
  // Read and display existing logs
  const content = fs.readFileSync(LOG_FILE, 'utf8');
  const allLines = content.trim().split('\n').filter(Boolean);
  
  // Get last N lines (or all if --all)
  const linesToShow = all ? allLines : allLines.slice(-lines);
  
  let shown = 0;
  for (const line of linesToShow) {
    try {
      const entry = JSON.parse(line);
      if (!shouldShow(entry.level)) continue;
      formatEntry(entry);
      shown++;
    } catch (e) {
      // Skip malformed lines
    }
  }
  
  if (!json && !follow) {
    if (shown === 0) {
      console.log(`${c.dim}No logs found${level ? ` at level '${level}' or above` : ''}${c.reset}`);
    } else {
      console.log(`${c.dim}─── Showing ${shown} of ${allLines.length} entries ───${c.reset}`);
    }
  }
  
  // Follow mode - tail the file
  if (follow) {
    if (!json) {
      console.log(`${c.cyan}● Following logs...${c.reset} ${c.dim}(Ctrl+C to stop)${c.reset}\n`);
    }
    
    let lastSize = fs.statSync(LOG_FILE).size;
    
    const watcher = setInterval(() => {
      try {
        const stats = fs.statSync(LOG_FILE);
        if (stats.size > lastSize) {
          // Read new content
          const fd = fs.openSync(LOG_FILE, 'r');
          const buffer = Buffer.alloc(stats.size - lastSize);
          fs.readSync(fd, buffer, 0, buffer.length, lastSize);
          fs.closeSync(fd);
          
          const newLines = buffer.toString().trim().split('\n').filter(Boolean);
          for (const line of newLines) {
            try {
              const entry = JSON.parse(line);
              if (!shouldShow(entry.level)) continue;
              formatEntry(entry);
            } catch (e) {}
          }
          
          lastSize = stats.size;
        } else if (stats.size < lastSize) {
          // File was truncated/rotated
          lastSize = stats.size;
        }
      } catch (e) {
        // File might be temporarily unavailable
      }
    }, 200);
    
    process.on('SIGINT', () => {
      clearInterval(watcher);
      if (!json) console.log(`\n${c.dim}Stopped.${c.reset}`);
      process.exit(0);
    });
    
    // Keep running
    await new Promise(() => {});
  }
}

async function cmdClick(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  if (!selector) {
    console.error(`${c.red}Usage: browser-ctl click <selector>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    await page.click(selector, { timeout: 5000 });
    console.log(`${c.green}Clicked:${c.reset} ${selector}`);
  } catch (err) {
    console.error(`${c.red}Click failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdType(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  const text = args.slice(1).join(' ');
  
  if (!selector || !text) {
    console.error(`${c.red}Usage: browser-ctl type <selector> <text>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    await page.fill(selector, text, { timeout: 5000 });
    console.log(`${c.green}Typed into ${selector}:${c.reset} "${text}"`);
  } catch (err) {
    console.error(`${c.red}Type failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdGoto(args) {
  const { page, browser } = await connect();
  
  let url = args[0];
  if (!url) {
    console.error(`${c.red}Usage: browser-ctl goto <url>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  // Handle relative URLs
  if (url.startsWith('/')) {
    const currentUrl = new URL(page.url());
    url = `${currentUrl.origin}${url}`;
  }
  
  try {
    await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
    console.log(`${c.green}Navigated to:${c.reset} ${page.url()}`);
  } catch (err) {
    console.error(`${c.red}Navigation failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdEval(args) {
  const { page, browser } = await connect();
  
  const script = args.join(' ');
  if (!script) {
    console.error(`${c.red}Usage: browser-ctl eval <javascript>${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    const result = await page.evaluate(script);
    if (typeof result === 'object') {
      console.log(JSON.stringify(result, null, 2));
    } else {
      console.log(result);
    }
  } catch (err) {
    console.error(`${c.red}Eval failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdHtml(args) {
  const { page, browser } = await connect();
  
  const selector = args[0];
  
  try {
    let html;
    if (selector) {
      const element = await page.$(selector);
      if (!element) {
        console.error(`${c.red}Element not found: ${selector}${c.reset}`);
        await browser.close();
        process.exit(1);
      }
      html = await element.innerHTML();
    } else {
      html = await page.content();
    }
    console.log(html);
  } catch (err) {
    console.error(`${c.red}HTML fetch failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdSnapshot(args) {
  const { page, browser } = await connect();
  
  let jsonOutput = args.includes('--json') || args.includes('-j');
  
  try {
    if (jsonOutput) {
      // Legacy JSON format - may not work over CDP connection
      if (!page.accessibility) {
        console.error(`${c.red}--json not available over CDP connection. Use YAML format (default).${c.reset}`);
        await browser.close();
        process.exit(1);
      }
      const snapshot = await page.accessibility.snapshot({ interestingOnly: true });
      console.log(JSON.stringify(snapshot, null, 2));
    } else {
      // New YAML format with refs
      const yaml = await page.evaluate((script) => {
        eval(script);
        return window.__devBrowser_getAISnapshot();
      }, SNAPSHOT_SCRIPT);
      console.log(yaml);
    }
  } catch (err) {
    console.error(`${c.red}Snapshot failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdClickRef(args) {
  const { page, browser } = await connect();
  
  const ref = args[0];
  if (!ref) {
    console.error(`${c.red}Usage: browser-ctl click-ref <ref>${c.reset}`);
    console.error(`Run 'browser-ctl snapshot' first to see available refs`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    // Inject snapshot script if not already present, then get element by ref
    const elementHandle = await page.evaluateHandle(({ script, refId }) => {
      if (!window.__devBrowser_getAISnapshot) eval(script);
      const refs = window.__browserCtlRefs;
      if (!refs) throw new Error("No refs found. Run 'browser-ctl snapshot' first.");
      const element = refs[refId];
      if (!element) throw new Error(`Ref "${refId}" not found. Run 'browser-ctl snapshot' to see available refs.`);
      return element;
    }, { script: SNAPSHOT_SCRIPT, refId: ref });
    
    const element = elementHandle.asElement();
    if (!element) {
      console.error(`${c.red}Ref "${ref}" did not resolve to an element${c.reset}`);
      await browser.close();
      process.exit(1);
    }
    
    await element.click({ timeout: 5000 });
    console.log(`${c.green}Clicked:${c.reset} ${ref}`);
  } catch (err) {
    console.error(`${c.red}Click failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdTypeRef(args) {
  const { page, browser } = await connect();
  
  const ref = args[0];
  const text = args.slice(1).join(' ');
  
  if (!ref || !text) {
    console.error(`${c.red}Usage: browser-ctl type-ref <ref> <text>${c.reset}`);
    console.error(`Run 'browser-ctl snapshot' first to see available refs`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    // Inject snapshot script if not already present, then get element by ref
    const elementHandle = await page.evaluateHandle(({ script, refId }) => {
      if (!window.__devBrowser_getAISnapshot) eval(script);
      const refs = window.__browserCtlRefs;
      if (!refs) throw new Error("No refs found. Run 'browser-ctl snapshot' first.");
      const element = refs[refId];
      if (!element) throw new Error(`Ref "${refId}" not found. Run 'browser-ctl snapshot' to see available refs.`);
      return element;
    }, { script: SNAPSHOT_SCRIPT, refId: ref });
    
    const element = elementHandle.asElement();
    if (!element) {
      console.error(`${c.red}Ref "${ref}" did not resolve to an element${c.reset}`);
      await browser.close();
      process.exit(1);
    }
    
    await element.fill(text, { timeout: 5000 });
    console.log(`${c.green}Typed into ${ref}:${c.reset} "${text}"`);
  } catch (err) {
    console.error(`${c.red}Type failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdUrl(args) {
  const { page, browser } = await connect();
  console.log(page.url());
  await browser.close();
}

async function cmdTitle(args) {
  const { page, browser } = await connect();
  console.log(await page.title());
  await browser.close();
}

async function cmdWait(args) {
  const { page, browser } = await connect();
  
  const target = args[0];
  const timeout = parseInt(args[1]) || 30000;
  
  if (!target) {
    console.error(`${c.red}Usage: browser-ctl wait <selector|url:pattern|text:content> [timeout_ms]${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  try {
    if (target.startsWith('url:')) {
      const pattern = target.slice(4);
      await page.waitForURL(`**${pattern}**`, { timeout });
    } else if (target.startsWith('text:')) {
      const text = target.slice(5);
      await page.waitForSelector(`text=${text}`, { timeout });
    } else {
      await page.waitForSelector(target, { timeout });
    }
    console.log(`${c.green}Wait complete:${c.reset} ${target}`);
  } catch (err) {
    console.error(`${c.red}Wait failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdReload(args) {
  const { page, browser } = await connect();
  
  try {
    await page.reload({ waitUntil: 'domcontentloaded' });
    console.log(`${c.green}Reloaded:${c.reset} ${page.url()}`);
  } catch (err) {
    console.error(`${c.red}Reload failed: ${err.message}${c.reset}`);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

async function cmdTabs(args) {
  const { browser, contexts } = await connect();
  
  const allPages = contexts.flatMap(ctx => ctx.pages());
  console.log(`${c.cyan}Open tabs (${allPages.length}):${c.reset}`);
  for (let i = 0; i < allPages.length; i++) {
    const p = allPages[i];
    const title = await p.title();
    console.log(`  ${i}: ${title || '(no title)'}`);
    console.log(`     ${c.dim}${p.url()}${c.reset}`);
  }
  
  await browser.close();
}

async function cmdTab(args) {
  const { browser, contexts } = await connect();
  
  const index = parseInt(args[0]);
  if (isNaN(index)) {
    console.error(`${c.red}Usage: browser-ctl tab <index>${c.reset}`);
    console.error(`Use 'browser-ctl tabs' to see available tabs`);
    await browser.close();
    process.exit(1);
  }
  
  const allPages = contexts.flatMap(ctx => ctx.pages());
  if (index < 0 || index >= allPages.length) {
    console.error(`${c.red}Invalid tab index: ${index}${c.reset}`);
    await browser.close();
    process.exit(1);
  }
  
  const targetPage = allPages[index];
  await targetPage.bringToFront();
  console.log(`${c.green}Switched to tab ${index}:${c.reset} ${await targetPage.title()}`);
  
  await browser.close();
}

// Test runner
async function cmdTest(args) {
  // Check for help flag first
  if (args.includes('--help') || args.includes('-h') || args.length === 0) {
    console.log(`
${c.cyan}browser-ctl test${c.reset} - Run browser tests from YAML/JSON specs

${c.yellow}USAGE${c.reset}
  browser-ctl test <file.yaml|directory> [options]

${c.yellow}OPTIONS${c.reset}
  --verbose, -v     Show detailed step-by-step output
  --json            Output results as JSON
  --junit=FILE      Write JUnit XML report to FILE
  --bail            Stop on first test failure
  --filter=PATTERN  Only run tests with names matching PATTERN

${c.yellow}EXAMPLES${c.reset}
  browser-ctl test tests/browser/auth.yaml
  browser-ctl test tests/browser/
  browser-ctl test tests/ --verbose
  browser-ctl test tests/ --junit=results.xml
  browser-ctl test tests/ --filter="login"

${c.yellow}TEST FILE FORMAT (YAML)${c.reset}
  name: My Test Suite
  setup:
    - goto: "http://localhost:5173"
    - wait: "[data-testid='app']"
  
  tests:
    - name: Login works
      steps:
        - click: "[data-testid='login-button']"
        - type:
            selector: "#email"
            text: "test@example.com"
        - click: "[data-testid='submit']"
        - wait: "[data-testid='dashboard']"
      assertions:
        - visible: "[data-testid='dashboard']"
        - url-includes: "/dashboard"

${c.yellow}AVAILABLE STEPS${c.reset}
  goto: <url>                    Navigate to URL
  click: <selector>              Click element
  type: { selector, text }       Type into input
  wait: <selector|number>        Wait for element or milliseconds
  sleep: <ms>                    Wait for milliseconds
  screenshot: [name]             Take screenshot
  eval: <javascript>             Execute JavaScript
  reload:                        Reload page

${c.yellow}AVAILABLE ASSERTIONS${c.reset}
  visible: <selector>            Element is visible
  hidden: <selector>             Element is hidden
  contains: { selector, text }   Element contains text
  url: <exact-url>               URL equals exactly
  url-includes: <substring>      URL contains substring
  url-matches: <regex>           URL matches regex
  count: { selector, equals|min|max }  Element count
  attribute: { selector, name, equals|includes }  Attribute value
`);
    process.exit(0);
  }
  
  // Parse arguments
  let testPath = args.find(a => !a.startsWith('-'));
  let verbose = args.includes('--verbose') || args.includes('-v');
  let jsonOutput = args.includes('--json');
  let junitOutput = args.find(a => a.startsWith('--junit='))?.split('=')[1];
  let bail = args.includes('--bail');
  let filter = args.find(a => a.startsWith('--filter='))?.split('=')[1];
  
  if (!testPath) {
    console.error(`${c.red}Usage: browser-ctl test <file.yaml|directory> [options]${c.reset}`);
    console.error(`Run 'browser-ctl test --help' for more information.`);
    process.exit(1);
  }
  
  // Collect test files
  let testFiles = [];
  const stat = fs.statSync(testPath);
  if (stat.isDirectory()) {
    const files = fs.readdirSync(testPath);
    testFiles = files
      .filter(f => f.endsWith('.yaml') || f.endsWith('.yml') || f.endsWith('.json'))
      .map(f => path.join(testPath, f));
  } else {
    testFiles = [testPath];
  }
  
  if (testFiles.length === 0) {
    console.error(`${c.red}No test files found${c.reset}`);
    process.exit(1);
  }
  
  // Results accumulator
  const allResults = {
    suites: [],
    totalTests: 0,
    passed: 0,
    failed: 0,
    skipped: 0,
    duration: 0
  };
  
  const startTime = Date.now();
  
  // Connect once for all tests
  const { browser, page } = await connect();
  
  for (const file of testFiles) {
    const content = fs.readFileSync(file, 'utf8');
    let suite;
    
    try {
      suite = file.endsWith('.json') ? JSON.parse(content) : yaml.load(content);
    } catch (err) {
      console.error(`${c.red}Failed to parse ${file}: ${err.message}${c.reset}`);
      continue;
    }
    
    const suiteResult = await runTestSuite(page, suite, { verbose, bail, filter, file });
    allResults.suites.push(suiteResult);
    allResults.totalTests += suiteResult.tests.length;
    allResults.passed += suiteResult.passed;
    allResults.failed += suiteResult.failed;
    allResults.skipped += suiteResult.skipped;
    
    if (bail && suiteResult.failed > 0) break;
  }
  
  allResults.duration = Date.now() - startTime;
  
  await browser.close();
  
  // Output results
  if (jsonOutput) {
    console.log(JSON.stringify(allResults, null, 2));
  } else if (junitOutput) {
    const junit = generateJUnitXml(allResults);
    fs.writeFileSync(junitOutput, junit);
    console.log(`${c.green}JUnit report written to:${c.reset} ${junitOutput}`);
    printSummary(allResults);
  } else {
    printSummary(allResults);
  }
  
  process.exit(allResults.failed > 0 ? 1 : 0);
}

async function runTestSuite(page, suite, opts) {
  const { verbose, bail, filter, file } = opts;
  const suiteName = suite.name || path.basename(file, path.extname(file));
  
  if (!opts.jsonOutput) {
    console.log(`\n${c.cyan}▶ ${suiteName}${c.reset}`);
  }
  
  const result = {
    name: suiteName,
    file,
    tests: [],
    passed: 0,
    failed: 0,
    skipped: 0,
    duration: 0
  };
  
  const suiteStart = Date.now();
  
  // Run setup steps
  if (suite.setup) {
    try {
      await runSteps(page, suite.setup, verbose);
    } catch (err) {
      console.error(`${c.red}  Setup failed: ${err.message}${c.reset}`);
      result.failed = (suite.tests || []).length;
      return result;
    }
  }
  
  // Run each test
  for (const test of (suite.tests || [])) {
    const testName = test.name || 'Unnamed test';
    
    // Apply filter
    if (filter && !testName.toLowerCase().includes(filter.toLowerCase())) {
      result.skipped++;
      result.tests.push({ name: testName, status: 'skipped' });
      continue;
    }
    
    const testStart = Date.now();
    const testResult = { name: testName, status: 'passed', duration: 0, error: null };
    
    try {
      // Run test steps
      if (test.steps) {
        await runSteps(page, test.steps, verbose);
      }
      
      // Run assertions
      if (test.assertions) {
        await runAssertions(page, test.assertions, verbose);
      }
      
      testResult.status = 'passed';
      result.passed++;
      if (!opts.jsonOutput) {
        console.log(`  ${c.green}✓${c.reset} ${testName}`);
      }
    } catch (err) {
      testResult.status = 'failed';
      testResult.error = err.message;
      result.failed++;
      if (!opts.jsonOutput) {
        console.log(`  ${c.red}✗${c.reset} ${testName}`);
        console.log(`    ${c.dim}${err.message}${c.reset}`);
      }
      
      // Take failure screenshot
      try {
        const screenshotPath = path.join(SCREENSHOT_DIR, `failure-${Date.now()}.png`);
        await page.screenshot({ path: screenshotPath });
        testResult.screenshot = screenshotPath;
        if (verbose) {
          console.log(`    ${c.dim}Screenshot: ${screenshotPath}${c.reset}`);
        }
      } catch (e) {}
      
      if (bail) break;
    }
    
    testResult.duration = Date.now() - testStart;
    result.tests.push(testResult);
  }
  
  result.duration = Date.now() - suiteStart;
  return result;
}

async function runSteps(page, steps, verbose) {
  for (const step of steps) {
    // Each step is an object like { goto: "/path" } or { click: "selector" }
    const [action, value] = Object.entries(step)[0];
    
    if (verbose) {
      console.log(`    ${c.dim}→ ${action}: ${JSON.stringify(value)}${c.reset}`);
    }
    
    switch (action) {
      case 'goto':
        let url = value;
        if (url.startsWith('/')) {
          const currentUrl = new URL(page.url());
          url = `${currentUrl.origin}${url}`;
        }
        await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
        break;
        
      case 'click':
        await page.click(value, { timeout: 10000 });
        break;
        
      case 'type':
        // { type: { selector: "#input", text: "hello" } }
        await page.fill(value.selector, value.text, { timeout: 10000 });
        break;
        
      case 'wait':
        if (typeof value === 'number') {
          await page.waitForTimeout(value);
        } else if (value.startsWith('url:')) {
          await page.waitForURL(`**${value.slice(4)}**`, { timeout: 30000 });
        } else {
          await page.waitForSelector(value, { timeout: 30000 });
        }
        break;
        
      case 'screenshot':
        const screenshotPath = typeof value === 'string' 
          ? path.join(SCREENSHOT_DIR, value + '.png')
          : path.join(SCREENSHOT_DIR, `step-${Date.now()}.png`);
        await page.screenshot({ path: screenshotPath });
        if (verbose) console.log(`      ${c.dim}Saved: ${screenshotPath}${c.reset}`);
        break;
        
      case 'eval':
        await page.evaluate(value);
        break;
        
      case 'reload':
        await page.reload({ waitUntil: 'domcontentloaded' });
        break;
        
      case 'sleep':
        await page.waitForTimeout(value);
        break;
        
      default:
        throw new Error(`Unknown step action: ${action}`);
    }
  }
}

async function runAssertions(page, assertions, verbose) {
  for (const assertion of assertions) {
    const [type, value] = Object.entries(assertion)[0];
    
    // Run the assertion first, then log on success
    switch (type) {
      case 'visible':
        const visibleEl = await page.$(value);
        if (!visibleEl) {
          throw new Error(`Element not found: ${value}`);
        }
        const isVisible = await visibleEl.isVisible();
        if (!isVisible) {
          throw new Error(`Element not visible: ${value}`);
        }
        break;
        
      case 'hidden':
        const hiddenEl = await page.$(value);
        if (hiddenEl && await hiddenEl.isVisible()) {
          throw new Error(`Element should be hidden: ${value}`);
        }
        break;
        
      case 'contains':
        // { contains: { selector: "h1", text: "Hello" } }
        const containsEl = await page.$(value.selector);
        if (!containsEl) {
          throw new Error(`Element not found: ${value.selector}`);
        }
        const text = await containsEl.textContent();
        if (!text.includes(value.text)) {
          throw new Error(`Element "${value.selector}" does not contain "${value.text}". Found: "${text.substring(0, 100)}"`);
        }
        break;
        
      case 'url':
        const currentUrl = page.url();
        if (currentUrl !== value) {
          throw new Error(`URL mismatch. Expected: ${value}, Got: ${currentUrl}`);
        }
        break;
        
      case 'url-includes':
        if (!page.url().includes(value)) {
          throw new Error(`URL should include "${value}". Got: ${page.url()}`);
        }
        break;
        
      case 'url-matches':
        if (!new RegExp(value).test(page.url())) {
          throw new Error(`URL should match "${value}". Got: ${page.url()}`);
        }
        break;
        
      case 'count':
        // { count: { selector: ".item", min: 1, max: 10 } } or { count: { selector: ".item", equals: 5 } }
        const elements = await page.$$(value.selector);
        const count = elements.length;
        if (value.equals !== undefined && count !== value.equals) {
          throw new Error(`Expected ${value.equals} elements for "${value.selector}", found ${count}`);
        }
        if (value.min !== undefined && count < value.min) {
          throw new Error(`Expected at least ${value.min} elements for "${value.selector}", found ${count}`);
        }
        if (value.max !== undefined && count > value.max) {
          throw new Error(`Expected at most ${value.max} elements for "${value.selector}", found ${count}`);
        }
        break;
        
      case 'attribute':
        // { attribute: { selector: "input", name: "value", equals: "hello" } }
        const attrEl = await page.$(value.selector);
        if (!attrEl) {
          throw new Error(`Element not found: ${value.selector}`);
        }
        const attrValue = await attrEl.getAttribute(value.name);
        if (value.equals !== undefined && attrValue !== value.equals) {
          throw new Error(`Attribute "${value.name}" of "${value.selector}" should be "${value.equals}", got "${attrValue}"`);
        }
        if (value.includes !== undefined && (!attrValue || !attrValue.includes(value.includes))) {
          throw new Error(`Attribute "${value.name}" should include "${value.includes}", got "${attrValue}"`);
        }
        break;
        
      case 'no-errors':
        // Check browser console for errors (would need log file access)
        // For now, this is a placeholder
        break;
        
      default:
        throw new Error(`Unknown assertion type: ${type}`);
    }
    
    // Log success after assertion passes
    if (verbose) {
      console.log(`    ${c.dim}✓ assert ${type}: ${JSON.stringify(value)}${c.reset}`);
    }
  }
}

function printSummary(results) {
  console.log(`\n${c.cyan}═══════════════════════════════════════${c.reset}`);
  console.log(`${c.cyan}Test Results${c.reset}`);
  console.log(`${c.cyan}═══════════════════════════════════════${c.reset}`);
  
  for (const suite of results.suites) {
    const icon = suite.failed > 0 ? c.red + '✗' : c.green + '✓';
    console.log(`\n${icon}${c.reset} ${suite.name}`);
    console.log(`  ${c.dim}${suite.passed} passed, ${suite.failed} failed, ${suite.skipped} skipped (${suite.duration}ms)${c.reset}`);
  }
  
  console.log(`\n${c.cyan}───────────────────────────────────────${c.reset}`);
  
  const icon = results.failed > 0 ? c.red + '✗' : c.green + '✓';
  console.log(`${icon} Total: ${results.passed} passed, ${results.failed} failed, ${results.skipped} skipped${c.reset}`);
  console.log(`${c.dim}Duration: ${results.duration}ms${c.reset}`);
  
  if (results.failed > 0) {
    console.log(`\n${c.red}Some tests failed!${c.reset}`);
  } else {
    console.log(`\n${c.green}All tests passed!${c.reset}`);
  }
}

function generateJUnitXml(results) {
  const lines = ['<?xml version="1.0" encoding="UTF-8"?>'];
  lines.push(`<testsuites tests="${results.totalTests}" failures="${results.failed}" time="${results.duration / 1000}">`);
  
  for (const suite of results.suites) {
    lines.push(`  <testsuite name="${escapeXml(suite.name)}" tests="${suite.tests.length}" failures="${suite.failed}" time="${suite.duration / 1000}">`);
    
    for (const test of suite.tests) {
      if (test.status === 'passed') {
        lines.push(`    <testcase name="${escapeXml(test.name)}" time="${test.duration / 1000}"/>`);
      } else if (test.status === 'failed') {
        lines.push(`    <testcase name="${escapeXml(test.name)}" time="${test.duration / 1000}">`);
        lines.push(`      <failure message="${escapeXml(test.error || 'Unknown error')}">${escapeXml(test.error || '')}</failure>`);
        lines.push(`    </testcase>`);
      } else {
        lines.push(`    <testcase name="${escapeXml(test.name)}" time="0">`);
        lines.push(`      <skipped/>`);
        lines.push(`    </testcase>`);
      }
    }
    
    lines.push(`  </testsuite>`);
  }
  
  lines.push('</testsuites>');
  return lines.join('\n');
}

function escapeXml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// Help
function showHelp() {
  console.log(`
${c.cyan}browser-ctl${c.reset} - Control browser via Playwright + CDP

${c.yellow}USAGE${c.reset}
  browser-ctl <command> [options]

${c.yellow}COMMANDS${c.reset}
  ${c.green}screenshot${c.reset} [selector] [--full] [-o file] [--max N] [--no-resize]
      Take screenshot of page or element
      Auto-resizes to 1500px max (AI-friendly). Use --no-resize to disable.
      
  ${c.green}logs${c.reset} [--level LEVEL] [--json] [-n LINES] [--follow] [--clear]
      Show console logs from log file (collected by browser-open daemon)
      -n, --lines N    Show last N lines (default: 50)
      -a, --all        Show all logs
      -f, --follow     Tail the log file (like tail -f)
      -c, --clear      Clear the log file
      Levels: debug, log, info, warn, error
      
  ${c.green}click${c.reset} <selector>
      Click an element by CSS selector
      
  ${c.green}click-ref${c.reset} <ref>
      Click an element by snapshot ref (e.g., e5)
      Run 'snapshot' first to see available refs
      
  ${c.green}type${c.reset} <selector> <text>
      Type text into an input by CSS selector
      
  ${c.green}type-ref${c.reset} <ref> <text>
      Type text into an input by snapshot ref (e.g., e5)
      Run 'snapshot' first to see available refs
      
  ${c.green}goto${c.reset} <url>
      Navigate to URL (supports relative paths like /accounts)
      
  ${c.green}eval${c.reset} <javascript>
      Execute JavaScript and print result
      
  ${c.green}html${c.reset} [selector]
      Get HTML content of page or element
      
  ${c.green}snapshot${c.reset} [--json]
      Get ARIA accessibility tree with clickable refs
      Output is YAML with [ref=eN] for each interactable element
      Use --json for legacy JSON format
      
  ${c.green}url${c.reset}
      Print current URL
      
  ${c.green}title${c.reset}
      Print page title
      
  ${c.green}wait${c.reset} <selector|url:pattern|text:content> [timeout]
      Wait for element, URL, or text
      
  ${c.green}reload${c.reset}
      Reload current page
      
  ${c.green}tabs${c.reset}
      List all open tabs
      
  ${c.green}tab${c.reset} <index>
      Switch to tab by index
      
  ${c.green}test${c.reset} <file.yaml|directory> [options]
      Run browser tests from YAML/JSON specs
      --verbose, -v     Show detailed step output
      --json            Output results as JSON
      --junit=FILE      Write JUnit XML report
      --bail            Stop on first failure
      --filter=PATTERN  Only run tests matching pattern

${c.yellow}EXAMPLES${c.reset}
  browser-ctl screenshot --full
  browser-ctl logs                        # Last 50 log entries
  browser-ctl logs --level error          # Only errors
  browser-ctl logs -n 100 --json          # Last 100 as JSON
  browser-ctl logs --follow               # Tail logs (like tail -f)
  browser-ctl click "button[type=submit]"
  browser-ctl type "#search" "hello world"
  browser-ctl goto /accounts
  browser-ctl eval "document.querySelectorAll('button').length"
  browser-ctl wait "text:Loading" 10000
  browser-ctl html ".sidebar"
  browser-ctl snapshot                         # YAML with refs like [ref=e5]
  browser-ctl click-ref e5                     # Click element by ref
  browser-ctl type-ref e3 "hello"              # Type into element by ref
  browser-ctl test tests/browser/              # Run all tests in directory
  browser-ctl test tests/browser/auth.yaml     # Run single test file
  browser-ctl test tests/ --junit=results.xml  # Generate JUnit report
  browser-ctl test tests/ --filter="login"     # Only run tests matching "login"

${c.yellow}ENVIRONMENT${c.reset}
  CDP_PORT         Chrome debugging port (default: 9222)
  CDP_HOST         Chrome host (default: localhost)
  SCREENSHOT_DIR   Screenshot output directory (default: /tmp/browser-ctl)

${c.yellow}SETUP${c.reset}
  First, launch Chrome with debugging enabled:
    ${c.cyan}browser-open${c.reset}
  
  Then use browser-ctl commands to interact with it.
`);
}

// Main
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  const cmdArgs = args.slice(1);
  
  if (!command || command === '--help' || command === '-h') {
    showHelp();
    process.exit(0);
  }
  
  switch (command) {
    case 'screenshot':
    case 'ss':
      await cmdScreenshot(cmdArgs);
      break;
    case 'logs':
    case 'log':
      await cmdLogs(cmdArgs);
      break;
    case 'click':
      await cmdClick(cmdArgs);
      break;
    case 'click-ref':
    case 'clickref':
      await cmdClickRef(cmdArgs);
      break;
    case 'type':
      await cmdType(cmdArgs);
      break;
    case 'type-ref':
    case 'typeref':
      await cmdTypeRef(cmdArgs);
      break;
    case 'goto':
    case 'go':
      await cmdGoto(cmdArgs);
      break;
    case 'eval':
    case 'js':
      await cmdEval(cmdArgs);
      break;
    case 'html':
      await cmdHtml(cmdArgs);
      break;
    case 'snapshot':
    case 'snap':
      await cmdSnapshot(cmdArgs);
      break;
    case 'url':
      await cmdUrl(cmdArgs);
      break;
    case 'title':
      await cmdTitle(cmdArgs);
      break;
    case 'wait':
      await cmdWait(cmdArgs);
      break;
    case 'reload':
      await cmdReload(cmdArgs);
      break;
    case 'tabs':
      await cmdTabs(cmdArgs);
      break;
    case 'tab':
      await cmdTab(cmdArgs);
      break;
    case 'test':
      await cmdTest(cmdArgs);
      break;
    default:
      console.error(`${c.red}Unknown command: ${command}${c.reset}`);
      console.error(`Run 'browser-ctl --help' for usage`);
      process.exit(1);
  }
}

main().catch(err => {
  console.error(`${c.red}Error: ${err.message}${c.reset}`);
  process.exit(1);
});
