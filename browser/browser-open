#!/bin/bash
# browser-open - Launch Chrome with remote debugging for browser-logs
#
# Usage:
#   browser-open                        # Open localhost:5173
#   browser-open http://localhost:3000  # Open specific URL
#   browser-open --port 9223            # Custom debugging port
#
# This enables the Chrome DevTools Protocol so browser-logs can connect.

set -euo pipefail

# Defaults
PORT=9222
PROFILE="/Users/blake/.cursor-chrome-profile"
URL="http://localhost:5173"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --port|-p)
            PORT="$2"
            shift 2
            ;;
        --profile)
            PROFILE="$2"
            shift 2
            ;;
        --force|-f)
            # Deprecated: no longer needed, kept for backwards compatibility
            shift
            ;;
        --help|-h)
            cat <<EOF
browser-open - Launch Chrome with remote debugging enabled

USAGE
  browser-open [options] [URL]

OPTIONS
  --port, -p N     Debugging port (default: 9222)
  --profile PATH   Chrome profile directory
  --help, -h       Show this help

EXAMPLES
  browser-open                           # Open localhost:5173
  browser-open http://localhost:3000     # Open specific URL
  browser-open --port 9223 http://...    # Custom port

NOTES
  Uses ~/.cursor-chrome-profile by default (preserves auth sessions)
  Automatically starts log collector - view logs with 'browser-ctl logs'
  Launches a separate Chrome instance - your personal Chrome stays untouched.
EOF
            exit 0
            ;;
        http://*|https://*)
            URL="$1"
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Resolve symlinks to get real script directory
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0" || echo "$0")")" && pwd)"
LOG_FILE="/tmp/browser-ctl-logs.jsonl"
PID_FILE="/tmp/browser-log-collector.pid"

# Start log collector if not running
start_collector() {
    if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
        return 0  # Already running
    fi
    # Kill any orphaned collectors
    pkill -f "log-collector.js" 2>/dev/null || true
    # Start collector in background with proper detachment
    ( cd "$SCRIPT_DIR" && node log-collector.js --port "$PORT" >> /tmp/browser-log-collector.log 2>&1 ) &
    disown
    sleep 1  # Give it time to start and create PID file
    if [[ -f "$PID_FILE" ]]; then
        return 0
    else
        echo "⚠️  Log collector failed to start. Check /tmp/browser-log-collector.log"
        return 1
    fi
}

# Check if debugging port is already active
if curl -s "http://localhost:$PORT/json/version" > /dev/null 2>&1; then
    echo "✓ Chrome debugging already active on port $PORT"
    echo "  Opening: $URL"
    # Use CDP to open URL in the automation Chrome (not personal Chrome)
    curl -s "http://localhost:$PORT/json/new?$URL" > /dev/null
    start_collector
    echo ""
    echo "Logs: browser-ctl logs"
    exit 0
fi

echo "Launching automation Chrome (separate instance) on port $PORT..."
echo "URL: $URL"
echo ""

open -na "Google Chrome" --args \
    --remote-debugging-port="$PORT" \
    --user-data-dir="$PROFILE" \
    "$URL"

# Wait for debugging port to become available
echo -n "Waiting for debugging port..."
for i in {1..10}; do
    if curl -s "http://localhost:$PORT/json/version" > /dev/null 2>&1; then
        echo " ready!"
        start_collector
        echo ""
        echo "Log collector started. View logs with:"
        echo "  browser-ctl logs"
        exit 0
    fi
    echo -n "."
    sleep 0.5
done

echo ""
echo "⚠️  Debugging port not responding after 5 seconds."
echo "   Check if another process is using port $PORT"
